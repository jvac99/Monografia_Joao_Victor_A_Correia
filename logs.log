2023-06-03 03:15:42,667:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-03 03:15:42,667:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-03 03:15:42,667:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-03 03:15:42,668:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-03 03:15:43,121:WARNING:
'prophet' is a soft dependency and not included in the pycaret installation. Please run: `pip install prophet` to install.
2023-06-03 03:18:06,136:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-03 03:18:06,136:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-03 03:18:06,136:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-03 03:18:06,136:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-03 03:18:06,524:WARNING:
'prophet' is a soft dependency and not included in the pycaret installation. Please run: `pip install prophet` to install.
2023-06-03 03:22:11,450:INFO:PyCaret ClassificationExperiment
2023-06-03 03:22:11,450:INFO:Logging name: clf-default-name
2023-06-03 03:22:11,450:INFO:ML Usecase: MLUsecase.CLASSIFICATION
2023-06-03 03:22:11,450:INFO:version 3.0.2
2023-06-03 03:22:11,450:INFO:Initializing setup()
2023-06-03 03:22:11,450:INFO:self.USI: 8c46
2023-06-03 03:22:11,450:INFO:self._variable_keys: {'_available_plots', 'fold_generator', 'log_plots_param', 'n_jobs_param', 'gpu_param', 'X_train', 'X', 'fold_groups_param', 'X_test', 'gpu_n_jobs_param', 'USI', 'fold_shuffle_param', 'y', 'exp_name_log', '_ml_usecase', 'target_param', 'is_multiclass', 'fix_imbalance', 'data', 'seed', 'idx', 'exp_id', 'pipeline', 'y_train', 'y_test', 'logging_param', 'html_param', 'memory'}
2023-06-03 03:22:11,450:INFO:Checking environment
2023-06-03 03:22:11,450:INFO:python_version: 3.10.11
2023-06-03 03:22:11,450:INFO:python_build: ('main', 'Apr 20 2023 18:56:50')
2023-06-03 03:22:11,452:INFO:machine: AMD64
2023-06-03 03:22:11,452:INFO:platform: Windows-10-10.0.19041-SP0
2023-06-03 03:22:11,459:INFO:Memory: svmem(total=16901767168, available=4787773440, percent=71.7, used=12113993728, free=4787773440)
2023-06-03 03:22:11,459:INFO:Physical Core: 4
2023-06-03 03:22:11,459:INFO:Logical Core: 8
2023-06-03 03:22:11,459:INFO:Checking libraries
2023-06-03 03:22:11,459:INFO:System:
2023-06-03 03:22:11,459:INFO:    python: 3.10.11 | packaged by Anaconda, Inc. | (main, Apr 20 2023, 18:56:50) [MSC v.1916 64 bit (AMD64)]
2023-06-03 03:22:11,459:INFO:executable: c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\python.exe
2023-06-03 03:22:11,459:INFO:   machine: Windows-10-10.0.19041-SP0
2023-06-03 03:22:11,459:INFO:PyCaret required dependencies:
2023-06-03 03:22:11,459:INFO:                 pip: 23.0.1
2023-06-03 03:22:11,459:INFO:          setuptools: 67.8.0
2023-06-03 03:22:11,459:INFO:             pycaret: 3.0.2
2023-06-03 03:22:11,459:INFO:             IPython: 8.10.0
2023-06-03 03:22:11,460:INFO:          ipywidgets: 8.0.6
2023-06-03 03:22:11,460:INFO:                tqdm: 4.65.0
2023-06-03 03:22:11,460:INFO:               numpy: 1.23.5
2023-06-03 03:22:11,460:INFO:              pandas: 1.5.3
2023-06-03 03:22:11,460:INFO:              jinja2: 3.1.2
2023-06-03 03:22:11,460:INFO:               scipy: 1.10.1
2023-06-03 03:22:11,460:INFO:              joblib: 1.2.0
2023-06-03 03:22:11,460:INFO:             sklearn: 1.2.2
2023-06-03 03:22:11,460:INFO:                pyod: 1.0.9
2023-06-03 03:22:11,460:INFO:            imblearn: 0.10.1
2023-06-03 03:22:11,460:INFO:   category_encoders: 2.6.1
2023-06-03 03:22:11,460:INFO:            lightgbm: 3.3.5
2023-06-03 03:22:11,460:INFO:               numba: 0.57.0
2023-06-03 03:22:11,460:INFO:            requests: 2.31.0
2023-06-03 03:22:11,460:INFO:          matplotlib: 3.7.1
2023-06-03 03:22:11,460:INFO:          scikitplot: 0.3.7
2023-06-03 03:22:11,460:INFO:         yellowbrick: 1.5
2023-06-03 03:22:11,460:INFO:              plotly: 5.14.1
2023-06-03 03:22:11,460:INFO:             kaleido: 0.2.1
2023-06-03 03:22:11,460:INFO:         statsmodels: 0.14.0
2023-06-03 03:22:11,460:INFO:              sktime: 0.17.0
2023-06-03 03:22:11,460:INFO:               tbats: 1.1.3
2023-06-03 03:22:11,460:INFO:            pmdarima: 2.0.3
2023-06-03 03:22:11,460:INFO:              psutil: 5.9.4
2023-06-03 03:22:11,460:INFO:PyCaret optional dependencies:
2023-06-03 03:22:11,478:INFO:                shap: Not installed
2023-06-03 03:22:11,478:INFO:           interpret: Not installed
2023-06-03 03:22:11,478:INFO:                umap: Not installed
2023-06-03 03:22:11,478:INFO:    pandas_profiling: Not installed
2023-06-03 03:22:11,478:INFO:  explainerdashboard: Not installed
2023-06-03 03:22:11,478:INFO:             autoviz: Not installed
2023-06-03 03:22:11,478:INFO:           fairlearn: Not installed
2023-06-03 03:22:11,478:INFO:             xgboost: Not installed
2023-06-03 03:22:11,478:INFO:            catboost: Not installed
2023-06-03 03:22:11,478:INFO:              kmodes: Not installed
2023-06-03 03:22:11,478:INFO:             mlxtend: Not installed
2023-06-03 03:22:11,478:INFO:       statsforecast: Not installed
2023-06-03 03:22:11,478:INFO:        tune_sklearn: Not installed
2023-06-03 03:22:11,478:INFO:                 ray: Not installed
2023-06-03 03:22:11,478:INFO:            hyperopt: Not installed
2023-06-03 03:22:11,478:INFO:              optuna: Not installed
2023-06-03 03:22:11,478:INFO:               skopt: Not installed
2023-06-03 03:22:11,478:INFO:              mlflow: Not installed
2023-06-03 03:22:11,478:INFO:              gradio: Not installed
2023-06-03 03:22:11,478:INFO:             fastapi: Not installed
2023-06-03 03:22:11,478:INFO:             uvicorn: Not installed
2023-06-03 03:22:11,478:INFO:              m2cgen: Not installed
2023-06-03 03:22:11,478:INFO:           evidently: Not installed
2023-06-03 03:22:11,478:INFO:               fugue: Not installed
2023-06-03 03:22:11,479:INFO:           streamlit: Not installed
2023-06-03 03:22:11,479:INFO:             prophet: Not installed
2023-06-03 03:22:11,479:INFO:None
2023-06-03 03:22:11,479:INFO:Set up data.
2023-06-03 03:24:35,152:INFO:PyCaret ClassificationExperiment
2023-06-03 03:24:35,152:INFO:Logging name: clf-default-name
2023-06-03 03:24:35,152:INFO:ML Usecase: MLUsecase.CLASSIFICATION
2023-06-03 03:24:35,152:INFO:version 3.0.2
2023-06-03 03:24:35,152:INFO:Initializing setup()
2023-06-03 03:24:35,152:INFO:self.USI: 5be8
2023-06-03 03:24:35,152:INFO:self._variable_keys: {'_available_plots', 'fold_generator', 'log_plots_param', 'n_jobs_param', 'gpu_param', 'X_train', 'X', 'fold_groups_param', 'X_test', 'gpu_n_jobs_param', 'USI', 'fold_shuffle_param', 'y', 'exp_name_log', '_ml_usecase', 'target_param', 'is_multiclass', 'fix_imbalance', 'data', 'seed', 'idx', 'exp_id', 'pipeline', 'y_train', 'y_test', 'logging_param', 'html_param', 'memory'}
2023-06-03 03:24:35,152:INFO:Checking environment
2023-06-03 03:24:35,152:INFO:python_version: 3.10.11
2023-06-03 03:24:35,154:INFO:python_build: ('main', 'Apr 20 2023 18:56:50')
2023-06-03 03:24:35,154:INFO:machine: AMD64
2023-06-03 03:24:35,154:INFO:platform: Windows-10-10.0.19041-SP0
2023-06-03 03:24:35,157:INFO:Memory: svmem(total=16901767168, available=4738015232, percent=72.0, used=12163751936, free=4738015232)
2023-06-03 03:24:35,157:INFO:Physical Core: 4
2023-06-03 03:24:35,157:INFO:Logical Core: 8
2023-06-03 03:24:35,157:INFO:Checking libraries
2023-06-03 03:24:35,157:INFO:System:
2023-06-03 03:24:35,157:INFO:    python: 3.10.11 | packaged by Anaconda, Inc. | (main, Apr 20 2023, 18:56:50) [MSC v.1916 64 bit (AMD64)]
2023-06-03 03:24:35,157:INFO:executable: c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\python.exe
2023-06-03 03:24:35,157:INFO:   machine: Windows-10-10.0.19041-SP0
2023-06-03 03:24:35,157:INFO:PyCaret required dependencies:
2023-06-03 03:24:35,157:INFO:                 pip: 23.0.1
2023-06-03 03:24:35,158:INFO:          setuptools: 67.8.0
2023-06-03 03:24:35,158:INFO:             pycaret: 3.0.2
2023-06-03 03:24:35,158:INFO:             IPython: 8.10.0
2023-06-03 03:24:35,158:INFO:          ipywidgets: 8.0.6
2023-06-03 03:24:35,158:INFO:                tqdm: 4.65.0
2023-06-03 03:24:35,158:INFO:               numpy: 1.23.5
2023-06-03 03:24:35,158:INFO:              pandas: 1.5.3
2023-06-03 03:24:35,158:INFO:              jinja2: 3.1.2
2023-06-03 03:24:35,158:INFO:               scipy: 1.10.1
2023-06-03 03:24:35,158:INFO:              joblib: 1.2.0
2023-06-03 03:24:35,158:INFO:             sklearn: 1.2.2
2023-06-03 03:24:35,158:INFO:                pyod: 1.0.9
2023-06-03 03:24:35,158:INFO:            imblearn: 0.10.1
2023-06-03 03:24:35,158:INFO:   category_encoders: 2.6.1
2023-06-03 03:24:35,158:INFO:            lightgbm: 3.3.5
2023-06-03 03:24:35,158:INFO:               numba: 0.57.0
2023-06-03 03:24:35,158:INFO:            requests: 2.31.0
2023-06-03 03:24:35,158:INFO:          matplotlib: 3.7.1
2023-06-03 03:24:35,158:INFO:          scikitplot: 0.3.7
2023-06-03 03:24:35,158:INFO:         yellowbrick: 1.5
2023-06-03 03:24:35,158:INFO:              plotly: 5.14.1
2023-06-03 03:24:35,158:INFO:             kaleido: 0.2.1
2023-06-03 03:24:35,158:INFO:         statsmodels: 0.14.0
2023-06-03 03:24:35,158:INFO:              sktime: 0.17.0
2023-06-03 03:24:35,158:INFO:               tbats: 1.1.3
2023-06-03 03:24:35,158:INFO:            pmdarima: 2.0.3
2023-06-03 03:24:35,158:INFO:              psutil: 5.9.4
2023-06-03 03:24:35,158:INFO:PyCaret optional dependencies:
2023-06-03 03:24:35,158:INFO:                shap: Not installed
2023-06-03 03:24:35,158:INFO:           interpret: Not installed
2023-06-03 03:24:35,159:INFO:                umap: Not installed
2023-06-03 03:24:35,159:INFO:    pandas_profiling: Not installed
2023-06-03 03:24:35,159:INFO:  explainerdashboard: Not installed
2023-06-03 03:24:35,159:INFO:             autoviz: Not installed
2023-06-03 03:24:35,159:INFO:           fairlearn: Not installed
2023-06-03 03:24:35,159:INFO:             xgboost: Not installed
2023-06-03 03:24:35,159:INFO:            catboost: Not installed
2023-06-03 03:24:35,159:INFO:              kmodes: Not installed
2023-06-03 03:24:35,159:INFO:             mlxtend: Not installed
2023-06-03 03:24:35,159:INFO:       statsforecast: Not installed
2023-06-03 03:24:35,159:INFO:        tune_sklearn: Not installed
2023-06-03 03:24:35,159:INFO:                 ray: Not installed
2023-06-03 03:24:35,159:INFO:            hyperopt: Not installed
2023-06-03 03:24:35,159:INFO:              optuna: Not installed
2023-06-03 03:24:35,159:INFO:               skopt: Not installed
2023-06-03 03:24:35,159:INFO:              mlflow: Not installed
2023-06-03 03:24:35,159:INFO:              gradio: Not installed
2023-06-03 03:24:35,159:INFO:             fastapi: Not installed
2023-06-03 03:24:35,159:INFO:             uvicorn: Not installed
2023-06-03 03:24:35,159:INFO:              m2cgen: Not installed
2023-06-03 03:24:35,159:INFO:           evidently: Not installed
2023-06-03 03:24:35,159:INFO:               fugue: Not installed
2023-06-03 03:24:35,159:INFO:           streamlit: Not installed
2023-06-03 03:24:35,159:INFO:             prophet: Not installed
2023-06-03 03:24:35,159:INFO:None
2023-06-03 03:24:35,159:INFO:Set up data.
2023-06-03 03:24:41,911:INFO:PyCaret ClassificationExperiment
2023-06-03 03:24:41,911:INFO:Logging name: clf-default-name
2023-06-03 03:24:41,911:INFO:ML Usecase: MLUsecase.CLASSIFICATION
2023-06-03 03:24:41,911:INFO:version 3.0.2
2023-06-03 03:24:41,911:INFO:Initializing setup()
2023-06-03 03:24:41,911:INFO:self.USI: 1564
2023-06-03 03:24:41,911:INFO:self._variable_keys: {'_available_plots', 'fold_generator', 'log_plots_param', 'n_jobs_param', 'gpu_param', 'X_train', 'X', 'fold_groups_param', 'X_test', 'gpu_n_jobs_param', 'USI', 'fold_shuffle_param', 'y', 'exp_name_log', '_ml_usecase', 'target_param', 'is_multiclass', 'fix_imbalance', 'data', 'seed', 'idx', 'exp_id', 'pipeline', 'y_train', 'y_test', 'logging_param', 'html_param', 'memory'}
2023-06-03 03:24:41,911:INFO:Checking environment
2023-06-03 03:24:41,911:INFO:python_version: 3.10.11
2023-06-03 03:24:41,911:INFO:python_build: ('main', 'Apr 20 2023 18:56:50')
2023-06-03 03:24:41,911:INFO:machine: AMD64
2023-06-03 03:24:41,911:INFO:platform: Windows-10-10.0.19041-SP0
2023-06-03 03:24:41,916:INFO:Memory: svmem(total=16901767168, available=4777201664, percent=71.7, used=12124565504, free=4777201664)
2023-06-03 03:24:41,916:INFO:Physical Core: 4
2023-06-03 03:24:41,916:INFO:Logical Core: 8
2023-06-03 03:24:41,916:INFO:Checking libraries
2023-06-03 03:24:41,916:INFO:System:
2023-06-03 03:24:41,916:INFO:    python: 3.10.11 | packaged by Anaconda, Inc. | (main, Apr 20 2023, 18:56:50) [MSC v.1916 64 bit (AMD64)]
2023-06-03 03:24:41,916:INFO:executable: c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\python.exe
2023-06-03 03:24:41,916:INFO:   machine: Windows-10-10.0.19041-SP0
2023-06-03 03:24:41,916:INFO:PyCaret required dependencies:
2023-06-03 03:24:41,916:INFO:                 pip: 23.0.1
2023-06-03 03:24:41,916:INFO:          setuptools: 67.8.0
2023-06-03 03:24:41,916:INFO:             pycaret: 3.0.2
2023-06-03 03:24:41,916:INFO:             IPython: 8.10.0
2023-06-03 03:24:41,916:INFO:          ipywidgets: 8.0.6
2023-06-03 03:24:41,916:INFO:                tqdm: 4.65.0
2023-06-03 03:24:41,917:INFO:               numpy: 1.23.5
2023-06-03 03:24:41,917:INFO:              pandas: 1.5.3
2023-06-03 03:24:41,917:INFO:              jinja2: 3.1.2
2023-06-03 03:24:41,917:INFO:               scipy: 1.10.1
2023-06-03 03:24:41,917:INFO:              joblib: 1.2.0
2023-06-03 03:24:41,917:INFO:             sklearn: 1.2.2
2023-06-03 03:24:41,917:INFO:                pyod: 1.0.9
2023-06-03 03:24:41,917:INFO:            imblearn: 0.10.1
2023-06-03 03:24:41,917:INFO:   category_encoders: 2.6.1
2023-06-03 03:24:41,917:INFO:            lightgbm: 3.3.5
2023-06-03 03:24:41,917:INFO:               numba: 0.57.0
2023-06-03 03:24:41,917:INFO:            requests: 2.31.0
2023-06-03 03:24:41,917:INFO:          matplotlib: 3.7.1
2023-06-03 03:24:41,917:INFO:          scikitplot: 0.3.7
2023-06-03 03:24:41,917:INFO:         yellowbrick: 1.5
2023-06-03 03:24:41,917:INFO:              plotly: 5.14.1
2023-06-03 03:24:41,917:INFO:             kaleido: 0.2.1
2023-06-03 03:24:41,917:INFO:         statsmodels: 0.14.0
2023-06-03 03:24:41,917:INFO:              sktime: 0.17.0
2023-06-03 03:24:41,917:INFO:               tbats: 1.1.3
2023-06-03 03:24:41,917:INFO:            pmdarima: 2.0.3
2023-06-03 03:24:41,918:INFO:              psutil: 5.9.4
2023-06-03 03:24:41,918:INFO:PyCaret optional dependencies:
2023-06-03 03:24:41,918:INFO:                shap: Not installed
2023-06-03 03:24:41,918:INFO:           interpret: Not installed
2023-06-03 03:24:41,918:INFO:                umap: Not installed
2023-06-03 03:24:41,918:INFO:    pandas_profiling: Not installed
2023-06-03 03:24:41,918:INFO:  explainerdashboard: Not installed
2023-06-03 03:24:41,918:INFO:             autoviz: Not installed
2023-06-03 03:24:41,918:INFO:           fairlearn: Not installed
2023-06-03 03:24:41,918:INFO:             xgboost: Not installed
2023-06-03 03:24:41,918:INFO:            catboost: Not installed
2023-06-03 03:24:41,918:INFO:              kmodes: Not installed
2023-06-03 03:24:41,918:INFO:             mlxtend: Not installed
2023-06-03 03:24:41,918:INFO:       statsforecast: Not installed
2023-06-03 03:24:41,918:INFO:        tune_sklearn: Not installed
2023-06-03 03:24:41,918:INFO:                 ray: Not installed
2023-06-03 03:24:41,918:INFO:            hyperopt: Not installed
2023-06-03 03:24:41,918:INFO:              optuna: Not installed
2023-06-03 03:24:41,919:INFO:               skopt: Not installed
2023-06-03 03:24:41,919:INFO:              mlflow: Not installed
2023-06-03 03:24:41,919:INFO:              gradio: Not installed
2023-06-03 03:24:41,919:INFO:             fastapi: Not installed
2023-06-03 03:24:41,919:INFO:             uvicorn: Not installed
2023-06-03 03:24:41,919:INFO:              m2cgen: Not installed
2023-06-03 03:24:41,919:INFO:           evidently: Not installed
2023-06-03 03:24:41,919:INFO:               fugue: Not installed
2023-06-03 03:24:41,919:INFO:           streamlit: Not installed
2023-06-03 03:24:41,919:INFO:             prophet: Not installed
2023-06-03 03:24:41,919:INFO:None
2023-06-03 03:24:41,919:INFO:Set up data.
2023-06-03 03:29:43,972:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-03 03:29:43,972:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-03 03:29:43,973:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-03 03:29:43,973:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-03 03:29:44,539:WARNING:
'prophet' is a soft dependency and not included in the pycaret installation. Please run: `pip install prophet` to install.
2023-06-19 13:54:05,505:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 13:54:05,506:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 13:54:05,506:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 13:54:05,506:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 13:54:09,546:WARNING:
'prophet' is a soft dependency and not included in the pycaret installation. Please run: `pip install prophet` to install.
2023-06-19 13:59:04,763:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 13:59:04,763:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 13:59:04,763:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 13:59:04,763:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 13:59:06,034:WARNING:
'prophet' is a soft dependency and not included in the pycaret installation. Please run: `pip install prophet` to install.
2023-06-19 14:28:17,664:INFO:PyCaret ClassificationExperiment
2023-06-19 14:28:17,665:INFO:Logging name: clf-default-name
2023-06-19 14:28:17,665:INFO:ML Usecase: MLUsecase.CLASSIFICATION
2023-06-19 14:28:17,665:INFO:version 3.0.2
2023-06-19 14:28:17,665:INFO:Initializing setup()
2023-06-19 14:28:17,665:INFO:self.USI: 3198
2023-06-19 14:28:17,665:INFO:self._variable_keys: {'X', 'n_jobs_param', 'pipeline', 'USI', 'idx', 'log_plots_param', 'y_test', '_available_plots', '_ml_usecase', 'is_multiclass', 'X_test', 'html_param', 'seed', 'gpu_n_jobs_param', 'y_train', 'X_train', 'exp_id', 'logging_param', 'target_param', 'memory', 'fold_groups_param', 'fold_generator', 'data', 'exp_name_log', 'gpu_param', 'fix_imbalance', 'fold_shuffle_param', 'y'}
2023-06-19 14:28:17,665:INFO:Checking environment
2023-06-19 14:28:17,665:INFO:python_version: 3.10.11
2023-06-19 14:28:17,666:INFO:python_build: ('main', 'Apr 20 2023 18:56:50')
2023-06-19 14:28:17,666:INFO:machine: AMD64
2023-06-19 14:28:17,666:INFO:platform: Windows-10-10.0.19041-SP0
2023-06-19 14:28:17,676:INFO:Memory: svmem(total=16901767168, available=1779412992, percent=89.5, used=15122354176, free=1779412992)
2023-06-19 14:28:17,678:INFO:Physical Core: 4
2023-06-19 14:28:17,678:INFO:Logical Core: 8
2023-06-19 14:28:17,678:INFO:Checking libraries
2023-06-19 14:28:17,678:INFO:System:
2023-06-19 14:28:17,678:INFO:    python: 3.10.11 | packaged by Anaconda, Inc. | (main, Apr 20 2023, 18:56:50) [MSC v.1916 64 bit (AMD64)]
2023-06-19 14:28:17,678:INFO:executable: c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\python.exe
2023-06-19 14:28:17,678:INFO:   machine: Windows-10-10.0.19041-SP0
2023-06-19 14:28:17,678:INFO:PyCaret required dependencies:
2023-06-19 14:28:17,678:INFO:                 pip: 23.0.1
2023-06-19 14:28:17,678:INFO:          setuptools: 67.8.0
2023-06-19 14:28:17,678:INFO:             pycaret: 3.0.2
2023-06-19 14:28:17,678:INFO:             IPython: 8.10.0
2023-06-19 14:28:17,679:INFO:          ipywidgets: 8.0.6
2023-06-19 14:28:17,679:INFO:                tqdm: 4.65.0
2023-06-19 14:28:17,679:INFO:               numpy: 1.23.5
2023-06-19 14:28:17,679:INFO:              pandas: 1.5.3
2023-06-19 14:28:17,679:INFO:              jinja2: 3.1.2
2023-06-19 14:28:17,679:INFO:               scipy: 1.10.1
2023-06-19 14:28:17,679:INFO:              joblib: 1.2.0
2023-06-19 14:28:17,679:INFO:             sklearn: 1.2.2
2023-06-19 14:28:17,679:INFO:                pyod: 1.0.9
2023-06-19 14:28:17,680:INFO:            imblearn: 0.10.1
2023-06-19 14:28:17,680:INFO:   category_encoders: 2.6.1
2023-06-19 14:28:17,680:INFO:            lightgbm: 3.3.5
2023-06-19 14:28:17,680:INFO:               numba: 0.57.0
2023-06-19 14:28:17,680:INFO:            requests: 2.31.0
2023-06-19 14:28:17,680:INFO:          matplotlib: 3.7.1
2023-06-19 14:28:17,681:INFO:          scikitplot: 0.3.7
2023-06-19 14:28:17,681:INFO:         yellowbrick: 1.5
2023-06-19 14:28:17,681:INFO:              plotly: 5.14.1
2023-06-19 14:28:17,681:INFO:             kaleido: 0.2.1
2023-06-19 14:28:17,681:INFO:         statsmodels: 0.14.0
2023-06-19 14:28:17,681:INFO:              sktime: 0.17.0
2023-06-19 14:28:17,681:INFO:               tbats: 1.1.3
2023-06-19 14:28:17,681:INFO:            pmdarima: 2.0.3
2023-06-19 14:28:17,681:INFO:              psutil: 5.9.4
2023-06-19 14:28:17,681:INFO:PyCaret optional dependencies:
2023-06-19 14:28:17,872:INFO:                shap: Not installed
2023-06-19 14:28:17,872:INFO:           interpret: Not installed
2023-06-19 14:28:17,872:INFO:                umap: Not installed
2023-06-19 14:28:17,872:INFO:    pandas_profiling: Not installed
2023-06-19 14:28:17,872:INFO:  explainerdashboard: Not installed
2023-06-19 14:28:17,872:INFO:             autoviz: Not installed
2023-06-19 14:28:17,872:INFO:           fairlearn: Not installed
2023-06-19 14:28:17,872:INFO:             xgboost: 1.7.6
2023-06-19 14:28:17,873:INFO:            catboost: Not installed
2023-06-19 14:28:17,873:INFO:              kmodes: Not installed
2023-06-19 14:28:17,873:INFO:             mlxtend: Not installed
2023-06-19 14:28:17,873:INFO:       statsforecast: Not installed
2023-06-19 14:28:17,873:INFO:        tune_sklearn: Not installed
2023-06-19 14:28:17,873:INFO:                 ray: Not installed
2023-06-19 14:28:17,873:INFO:            hyperopt: Not installed
2023-06-19 14:28:17,873:INFO:              optuna: Not installed
2023-06-19 14:28:17,873:INFO:               skopt: Not installed
2023-06-19 14:28:17,873:INFO:              mlflow: Not installed
2023-06-19 14:28:17,873:INFO:              gradio: Not installed
2023-06-19 14:28:17,874:INFO:             fastapi: Not installed
2023-06-19 14:28:17,874:INFO:             uvicorn: Not installed
2023-06-19 14:28:17,874:INFO:              m2cgen: Not installed
2023-06-19 14:28:17,874:INFO:           evidently: Not installed
2023-06-19 14:28:17,874:INFO:               fugue: Not installed
2023-06-19 14:28:17,875:INFO:           streamlit: Not installed
2023-06-19 14:28:17,875:INFO:             prophet: Not installed
2023-06-19 14:28:17,875:INFO:None
2023-06-19 14:28:17,875:INFO:Set up data.
2023-06-19 14:33:39,225:INFO:PyCaret ClassificationExperiment
2023-06-19 14:33:39,226:INFO:Logging name: clf-default-name
2023-06-19 14:33:39,226:INFO:ML Usecase: MLUsecase.CLASSIFICATION
2023-06-19 14:33:39,226:INFO:version 3.0.2
2023-06-19 14:33:39,226:INFO:Initializing setup()
2023-06-19 14:33:39,226:INFO:self.USI: d48d
2023-06-19 14:33:39,226:INFO:self._variable_keys: {'X', 'n_jobs_param', 'pipeline', 'USI', 'idx', 'log_plots_param', 'y_test', '_available_plots', '_ml_usecase', 'is_multiclass', 'X_test', 'html_param', 'seed', 'gpu_n_jobs_param', 'y_train', 'X_train', 'exp_id', 'logging_param', 'target_param', 'memory', 'fold_groups_param', 'fold_generator', 'data', 'exp_name_log', 'gpu_param', 'fix_imbalance', 'fold_shuffle_param', 'y'}
2023-06-19 14:33:39,226:INFO:Checking environment
2023-06-19 14:33:39,226:INFO:python_version: 3.10.11
2023-06-19 14:33:39,226:INFO:python_build: ('main', 'Apr 20 2023 18:56:50')
2023-06-19 14:33:39,226:INFO:machine: AMD64
2023-06-19 14:33:39,226:INFO:platform: Windows-10-10.0.19041-SP0
2023-06-19 14:33:39,234:INFO:Memory: svmem(total=16901767168, available=1444290560, percent=91.5, used=15457476608, free=1444290560)
2023-06-19 14:33:39,234:INFO:Physical Core: 4
2023-06-19 14:33:39,234:INFO:Logical Core: 8
2023-06-19 14:33:39,234:INFO:Checking libraries
2023-06-19 14:33:39,234:INFO:System:
2023-06-19 14:33:39,234:INFO:    python: 3.10.11 | packaged by Anaconda, Inc. | (main, Apr 20 2023, 18:56:50) [MSC v.1916 64 bit (AMD64)]
2023-06-19 14:33:39,234:INFO:executable: c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\python.exe
2023-06-19 14:33:39,235:INFO:   machine: Windows-10-10.0.19041-SP0
2023-06-19 14:33:39,235:INFO:PyCaret required dependencies:
2023-06-19 14:33:39,235:INFO:                 pip: 23.0.1
2023-06-19 14:33:39,235:INFO:          setuptools: 67.8.0
2023-06-19 14:33:39,235:INFO:             pycaret: 3.0.2
2023-06-19 14:33:39,235:INFO:             IPython: 8.10.0
2023-06-19 14:33:39,235:INFO:          ipywidgets: 8.0.6
2023-06-19 14:33:39,235:INFO:                tqdm: 4.65.0
2023-06-19 14:33:39,235:INFO:               numpy: 1.23.5
2023-06-19 14:33:39,236:INFO:              pandas: 1.5.3
2023-06-19 14:33:39,236:INFO:              jinja2: 3.1.2
2023-06-19 14:33:39,236:INFO:               scipy: 1.10.1
2023-06-19 14:33:39,236:INFO:              joblib: 1.2.0
2023-06-19 14:33:39,236:INFO:             sklearn: 1.2.2
2023-06-19 14:33:39,236:INFO:                pyod: 1.0.9
2023-06-19 14:33:39,236:INFO:            imblearn: 0.10.1
2023-06-19 14:33:39,236:INFO:   category_encoders: 2.6.1
2023-06-19 14:33:39,236:INFO:            lightgbm: 3.3.5
2023-06-19 14:33:39,236:INFO:               numba: 0.57.0
2023-06-19 14:33:39,237:INFO:            requests: 2.31.0
2023-06-19 14:33:39,237:INFO:          matplotlib: 3.7.1
2023-06-19 14:33:39,237:INFO:          scikitplot: 0.3.7
2023-06-19 14:33:39,237:INFO:         yellowbrick: 1.5
2023-06-19 14:33:39,237:INFO:              plotly: 5.14.1
2023-06-19 14:33:39,237:INFO:             kaleido: 0.2.1
2023-06-19 14:33:39,237:INFO:         statsmodels: 0.14.0
2023-06-19 14:33:39,237:INFO:              sktime: 0.17.0
2023-06-19 14:33:39,237:INFO:               tbats: 1.1.3
2023-06-19 14:33:39,237:INFO:            pmdarima: 2.0.3
2023-06-19 14:33:39,237:INFO:              psutil: 5.9.4
2023-06-19 14:33:39,237:INFO:PyCaret optional dependencies:
2023-06-19 14:33:39,237:INFO:                shap: Not installed
2023-06-19 14:33:39,237:INFO:           interpret: Not installed
2023-06-19 14:33:39,237:INFO:                umap: Not installed
2023-06-19 14:33:39,237:INFO:    pandas_profiling: Not installed
2023-06-19 14:33:39,238:INFO:  explainerdashboard: Not installed
2023-06-19 14:33:39,238:INFO:             autoviz: Not installed
2023-06-19 14:33:39,238:INFO:           fairlearn: Not installed
2023-06-19 14:33:39,238:INFO:             xgboost: 1.7.6
2023-06-19 14:33:39,238:INFO:            catboost: Not installed
2023-06-19 14:33:39,238:INFO:              kmodes: Not installed
2023-06-19 14:33:39,238:INFO:             mlxtend: Not installed
2023-06-19 14:33:39,238:INFO:       statsforecast: Not installed
2023-06-19 14:33:39,238:INFO:        tune_sklearn: Not installed
2023-06-19 14:33:39,238:INFO:                 ray: Not installed
2023-06-19 14:33:39,238:INFO:            hyperopt: Not installed
2023-06-19 14:33:39,239:INFO:              optuna: Not installed
2023-06-19 14:33:39,239:INFO:               skopt: Not installed
2023-06-19 14:33:39,239:INFO:              mlflow: Not installed
2023-06-19 14:33:39,239:INFO:              gradio: Not installed
2023-06-19 14:33:39,239:INFO:             fastapi: Not installed
2023-06-19 14:33:39,239:INFO:             uvicorn: Not installed
2023-06-19 14:33:39,239:INFO:              m2cgen: Not installed
2023-06-19 14:33:39,239:INFO:           evidently: Not installed
2023-06-19 14:33:39,239:INFO:               fugue: Not installed
2023-06-19 14:33:39,239:INFO:           streamlit: Not installed
2023-06-19 14:33:39,239:INFO:             prophet: Not installed
2023-06-19 14:33:39,239:INFO:None
2023-06-19 14:33:39,240:INFO:Set up data.
2023-06-19 14:36:03,513:INFO:PyCaret ClassificationExperiment
2023-06-19 14:36:03,513:INFO:Logging name: clf-default-name
2023-06-19 14:36:03,513:INFO:ML Usecase: MLUsecase.CLASSIFICATION
2023-06-19 14:36:03,513:INFO:version 3.0.2
2023-06-19 14:36:03,513:INFO:Initializing setup()
2023-06-19 14:36:03,513:INFO:self.USI: 0de6
2023-06-19 14:36:03,513:INFO:self._variable_keys: {'X', 'n_jobs_param', 'pipeline', 'USI', 'idx', 'log_plots_param', 'y_test', '_available_plots', '_ml_usecase', 'is_multiclass', 'X_test', 'html_param', 'seed', 'gpu_n_jobs_param', 'y_train', 'X_train', 'exp_id', 'logging_param', 'target_param', 'memory', 'fold_groups_param', 'fold_generator', 'data', 'exp_name_log', 'gpu_param', 'fix_imbalance', 'fold_shuffle_param', 'y'}
2023-06-19 14:36:03,513:INFO:Checking environment
2023-06-19 14:36:03,513:INFO:python_version: 3.10.11
2023-06-19 14:36:03,513:INFO:python_build: ('main', 'Apr 20 2023 18:56:50')
2023-06-19 14:36:03,514:INFO:machine: AMD64
2023-06-19 14:36:03,514:INFO:platform: Windows-10-10.0.19041-SP0
2023-06-19 14:36:03,524:INFO:Memory: svmem(total=16901767168, available=1307074560, percent=92.3, used=15594692608, free=1307074560)
2023-06-19 14:36:03,524:INFO:Physical Core: 4
2023-06-19 14:36:03,524:INFO:Logical Core: 8
2023-06-19 14:36:03,525:INFO:Checking libraries
2023-06-19 14:36:03,525:INFO:System:
2023-06-19 14:36:03,525:INFO:    python: 3.10.11 | packaged by Anaconda, Inc. | (main, Apr 20 2023, 18:56:50) [MSC v.1916 64 bit (AMD64)]
2023-06-19 14:36:03,525:INFO:executable: c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\python.exe
2023-06-19 14:36:03,525:INFO:   machine: Windows-10-10.0.19041-SP0
2023-06-19 14:36:03,525:INFO:PyCaret required dependencies:
2023-06-19 14:36:03,525:INFO:                 pip: 23.0.1
2023-06-19 14:36:03,525:INFO:          setuptools: 67.8.0
2023-06-19 14:36:03,525:INFO:             pycaret: 3.0.2
2023-06-19 14:36:03,525:INFO:             IPython: 8.10.0
2023-06-19 14:36:03,526:INFO:          ipywidgets: 8.0.6
2023-06-19 14:36:03,526:INFO:                tqdm: 4.65.0
2023-06-19 14:36:03,526:INFO:               numpy: 1.23.5
2023-06-19 14:36:03,526:INFO:              pandas: 1.5.3
2023-06-19 14:36:03,526:INFO:              jinja2: 3.1.2
2023-06-19 14:36:03,526:INFO:               scipy: 1.10.1
2023-06-19 14:36:03,526:INFO:              joblib: 1.2.0
2023-06-19 14:36:03,526:INFO:             sklearn: 1.2.2
2023-06-19 14:36:03,526:INFO:                pyod: 1.0.9
2023-06-19 14:36:03,526:INFO:            imblearn: 0.10.1
2023-06-19 14:36:03,526:INFO:   category_encoders: 2.6.1
2023-06-19 14:36:03,526:INFO:            lightgbm: 3.3.5
2023-06-19 14:36:03,527:INFO:               numba: 0.57.0
2023-06-19 14:36:03,527:INFO:            requests: 2.31.0
2023-06-19 14:36:03,527:INFO:          matplotlib: 3.7.1
2023-06-19 14:36:03,527:INFO:          scikitplot: 0.3.7
2023-06-19 14:36:03,527:INFO:         yellowbrick: 1.5
2023-06-19 14:36:03,527:INFO:              plotly: 5.14.1
2023-06-19 14:36:03,527:INFO:             kaleido: 0.2.1
2023-06-19 14:36:03,527:INFO:         statsmodels: 0.14.0
2023-06-19 14:36:03,527:INFO:              sktime: 0.17.0
2023-06-19 14:36:03,527:INFO:               tbats: 1.1.3
2023-06-19 14:36:03,527:INFO:            pmdarima: 2.0.3
2023-06-19 14:36:03,528:INFO:              psutil: 5.9.4
2023-06-19 14:36:03,528:INFO:PyCaret optional dependencies:
2023-06-19 14:36:03,528:INFO:                shap: Not installed
2023-06-19 14:36:03,528:INFO:           interpret: Not installed
2023-06-19 14:36:03,528:INFO:                umap: Not installed
2023-06-19 14:36:03,528:INFO:    pandas_profiling: Not installed
2023-06-19 14:36:03,528:INFO:  explainerdashboard: Not installed
2023-06-19 14:36:03,528:INFO:             autoviz: Not installed
2023-06-19 14:36:03,528:INFO:           fairlearn: Not installed
2023-06-19 14:36:03,529:INFO:             xgboost: 1.7.6
2023-06-19 14:36:03,529:INFO:            catboost: Not installed
2023-06-19 14:36:03,529:INFO:              kmodes: Not installed
2023-06-19 14:36:03,529:INFO:             mlxtend: Not installed
2023-06-19 14:36:03,529:INFO:       statsforecast: Not installed
2023-06-19 14:36:03,529:INFO:        tune_sklearn: Not installed
2023-06-19 14:36:03,529:INFO:                 ray: Not installed
2023-06-19 14:36:03,529:INFO:            hyperopt: Not installed
2023-06-19 14:36:03,529:INFO:              optuna: Not installed
2023-06-19 14:36:03,529:INFO:               skopt: Not installed
2023-06-19 14:36:03,529:INFO:              mlflow: Not installed
2023-06-19 14:36:03,530:INFO:              gradio: Not installed
2023-06-19 14:36:03,530:INFO:             fastapi: Not installed
2023-06-19 14:36:03,530:INFO:             uvicorn: Not installed
2023-06-19 14:36:03,530:INFO:              m2cgen: Not installed
2023-06-19 14:36:03,530:INFO:           evidently: Not installed
2023-06-19 14:36:03,530:INFO:               fugue: Not installed
2023-06-19 14:36:03,530:INFO:           streamlit: Not installed
2023-06-19 14:36:03,530:INFO:             prophet: Not installed
2023-06-19 14:36:03,530:INFO:None
2023-06-19 14:36:03,530:INFO:Set up data.
2023-06-19 14:38:00,560:INFO:PyCaret ClassificationExperiment
2023-06-19 14:38:00,561:INFO:Logging name: clf-default-name
2023-06-19 14:38:00,561:INFO:ML Usecase: MLUsecase.CLASSIFICATION
2023-06-19 14:38:00,561:INFO:version 3.0.2
2023-06-19 14:38:00,561:INFO:Initializing setup()
2023-06-19 14:38:00,561:INFO:self.USI: d3fe
2023-06-19 14:38:00,561:INFO:self._variable_keys: {'X', 'n_jobs_param', 'pipeline', 'USI', 'idx', 'log_plots_param', 'y_test', '_available_plots', '_ml_usecase', 'is_multiclass', 'X_test', 'html_param', 'seed', 'gpu_n_jobs_param', 'y_train', 'X_train', 'exp_id', 'logging_param', 'target_param', 'memory', 'fold_groups_param', 'fold_generator', 'data', 'exp_name_log', 'gpu_param', 'fix_imbalance', 'fold_shuffle_param', 'y'}
2023-06-19 14:38:00,561:INFO:Checking environment
2023-06-19 14:38:00,561:INFO:python_version: 3.10.11
2023-06-19 14:38:00,561:INFO:python_build: ('main', 'Apr 20 2023 18:56:50')
2023-06-19 14:38:00,562:INFO:machine: AMD64
2023-06-19 14:38:00,562:INFO:platform: Windows-10-10.0.19041-SP0
2023-06-19 14:38:00,569:INFO:Memory: svmem(total=16901767168, available=1782931456, percent=89.5, used=15118835712, free=1782931456)
2023-06-19 14:38:00,569:INFO:Physical Core: 4
2023-06-19 14:38:00,569:INFO:Logical Core: 8
2023-06-19 14:38:00,569:INFO:Checking libraries
2023-06-19 14:38:00,569:INFO:System:
2023-06-19 14:38:00,569:INFO:    python: 3.10.11 | packaged by Anaconda, Inc. | (main, Apr 20 2023, 18:56:50) [MSC v.1916 64 bit (AMD64)]
2023-06-19 14:38:00,569:INFO:executable: c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\python.exe
2023-06-19 14:38:00,570:INFO:   machine: Windows-10-10.0.19041-SP0
2023-06-19 14:38:00,570:INFO:PyCaret required dependencies:
2023-06-19 14:38:00,570:INFO:                 pip: 23.0.1
2023-06-19 14:38:00,570:INFO:          setuptools: 67.8.0
2023-06-19 14:38:00,570:INFO:             pycaret: 3.0.2
2023-06-19 14:38:00,570:INFO:             IPython: 8.10.0
2023-06-19 14:38:00,570:INFO:          ipywidgets: 8.0.6
2023-06-19 14:38:00,570:INFO:                tqdm: 4.65.0
2023-06-19 14:38:00,570:INFO:               numpy: 1.23.5
2023-06-19 14:38:00,570:INFO:              pandas: 1.5.3
2023-06-19 14:38:00,571:INFO:              jinja2: 3.1.2
2023-06-19 14:38:00,572:INFO:               scipy: 1.10.1
2023-06-19 14:38:00,572:INFO:              joblib: 1.2.0
2023-06-19 14:38:00,572:INFO:             sklearn: 1.2.2
2023-06-19 14:38:00,572:INFO:                pyod: 1.0.9
2023-06-19 14:38:00,572:INFO:            imblearn: 0.10.1
2023-06-19 14:38:00,572:INFO:   category_encoders: 2.6.1
2023-06-19 14:38:00,572:INFO:            lightgbm: 3.3.5
2023-06-19 14:38:00,572:INFO:               numba: 0.57.0
2023-06-19 14:38:00,572:INFO:            requests: 2.31.0
2023-06-19 14:38:00,572:INFO:          matplotlib: 3.7.1
2023-06-19 14:38:00,572:INFO:          scikitplot: 0.3.7
2023-06-19 14:38:00,572:INFO:         yellowbrick: 1.5
2023-06-19 14:38:00,572:INFO:              plotly: 5.14.1
2023-06-19 14:38:00,572:INFO:             kaleido: 0.2.1
2023-06-19 14:38:00,572:INFO:         statsmodels: 0.14.0
2023-06-19 14:38:00,572:INFO:              sktime: 0.17.0
2023-06-19 14:38:00,572:INFO:               tbats: 1.1.3
2023-06-19 14:38:00,572:INFO:            pmdarima: 2.0.3
2023-06-19 14:38:00,573:INFO:              psutil: 5.9.4
2023-06-19 14:38:00,573:INFO:PyCaret optional dependencies:
2023-06-19 14:38:00,573:INFO:                shap: Not installed
2023-06-19 14:38:00,573:INFO:           interpret: Not installed
2023-06-19 14:38:00,573:INFO:                umap: Not installed
2023-06-19 14:38:00,573:INFO:    pandas_profiling: Not installed
2023-06-19 14:38:00,573:INFO:  explainerdashboard: Not installed
2023-06-19 14:38:00,573:INFO:             autoviz: Not installed
2023-06-19 14:38:00,573:INFO:           fairlearn: Not installed
2023-06-19 14:38:00,573:INFO:             xgboost: 1.7.6
2023-06-19 14:38:00,573:INFO:            catboost: Not installed
2023-06-19 14:38:00,574:INFO:              kmodes: Not installed
2023-06-19 14:38:00,574:INFO:             mlxtend: Not installed
2023-06-19 14:38:00,574:INFO:       statsforecast: Not installed
2023-06-19 14:38:00,574:INFO:        tune_sklearn: Not installed
2023-06-19 14:38:00,574:INFO:                 ray: Not installed
2023-06-19 14:38:00,574:INFO:            hyperopt: Not installed
2023-06-19 14:38:00,574:INFO:              optuna: Not installed
2023-06-19 14:38:00,574:INFO:               skopt: Not installed
2023-06-19 14:38:00,574:INFO:              mlflow: Not installed
2023-06-19 14:38:00,574:INFO:              gradio: Not installed
2023-06-19 14:38:00,574:INFO:             fastapi: Not installed
2023-06-19 14:38:00,574:INFO:             uvicorn: Not installed
2023-06-19 14:38:00,575:INFO:              m2cgen: Not installed
2023-06-19 14:38:00,575:INFO:           evidently: Not installed
2023-06-19 14:38:00,575:INFO:               fugue: Not installed
2023-06-19 14:38:00,575:INFO:           streamlit: Not installed
2023-06-19 14:38:00,575:INFO:             prophet: Not installed
2023-06-19 14:38:00,575:INFO:None
2023-06-19 14:38:00,576:INFO:Set up data.
2023-06-19 14:38:20,301:INFO:PyCaret ClassificationExperiment
2023-06-19 14:38:20,301:INFO:Logging name: clf-default-name
2023-06-19 14:38:20,301:INFO:ML Usecase: MLUsecase.CLASSIFICATION
2023-06-19 14:38:20,301:INFO:version 3.0.2
2023-06-19 14:38:20,301:INFO:Initializing setup()
2023-06-19 14:38:20,301:INFO:self.USI: a7fa
2023-06-19 14:38:20,302:INFO:self._variable_keys: {'X', 'n_jobs_param', 'pipeline', 'USI', 'idx', 'log_plots_param', 'y_test', '_available_plots', '_ml_usecase', 'is_multiclass', 'X_test', 'html_param', 'seed', 'gpu_n_jobs_param', 'y_train', 'X_train', 'exp_id', 'logging_param', 'target_param', 'memory', 'fold_groups_param', 'fold_generator', 'data', 'exp_name_log', 'gpu_param', 'fix_imbalance', 'fold_shuffle_param', 'y'}
2023-06-19 14:38:20,302:INFO:Checking environment
2023-06-19 14:38:20,302:INFO:python_version: 3.10.11
2023-06-19 14:38:20,302:INFO:python_build: ('main', 'Apr 20 2023 18:56:50')
2023-06-19 14:38:20,302:INFO:machine: AMD64
2023-06-19 14:38:20,302:INFO:platform: Windows-10-10.0.19041-SP0
2023-06-19 14:38:20,313:INFO:Memory: svmem(total=16901767168, available=1404346368, percent=91.7, used=15497420800, free=1404346368)
2023-06-19 14:38:20,313:INFO:Physical Core: 4
2023-06-19 14:38:20,313:INFO:Logical Core: 8
2023-06-19 14:38:20,313:INFO:Checking libraries
2023-06-19 14:38:20,313:INFO:System:
2023-06-19 14:38:20,314:INFO:    python: 3.10.11 | packaged by Anaconda, Inc. | (main, Apr 20 2023, 18:56:50) [MSC v.1916 64 bit (AMD64)]
2023-06-19 14:38:20,314:INFO:executable: c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\python.exe
2023-06-19 14:38:20,314:INFO:   machine: Windows-10-10.0.19041-SP0
2023-06-19 14:38:20,314:INFO:PyCaret required dependencies:
2023-06-19 14:38:20,314:INFO:                 pip: 23.0.1
2023-06-19 14:38:20,314:INFO:          setuptools: 67.8.0
2023-06-19 14:38:20,314:INFO:             pycaret: 3.0.2
2023-06-19 14:38:20,315:INFO:             IPython: 8.10.0
2023-06-19 14:38:20,315:INFO:          ipywidgets: 8.0.6
2023-06-19 14:38:20,315:INFO:                tqdm: 4.65.0
2023-06-19 14:38:20,315:INFO:               numpy: 1.23.5
2023-06-19 14:38:20,315:INFO:              pandas: 1.5.3
2023-06-19 14:38:20,315:INFO:              jinja2: 3.1.2
2023-06-19 14:38:20,315:INFO:               scipy: 1.10.1
2023-06-19 14:38:20,315:INFO:              joblib: 1.2.0
2023-06-19 14:38:20,315:INFO:             sklearn: 1.2.2
2023-06-19 14:38:20,315:INFO:                pyod: 1.0.9
2023-06-19 14:38:20,316:INFO:            imblearn: 0.10.1
2023-06-19 14:38:20,316:INFO:   category_encoders: 2.6.1
2023-06-19 14:38:20,316:INFO:            lightgbm: 3.3.5
2023-06-19 14:38:20,316:INFO:               numba: 0.57.0
2023-06-19 14:38:20,316:INFO:            requests: 2.31.0
2023-06-19 14:38:20,316:INFO:          matplotlib: 3.7.1
2023-06-19 14:38:20,316:INFO:          scikitplot: 0.3.7
2023-06-19 14:38:20,316:INFO:         yellowbrick: 1.5
2023-06-19 14:38:20,316:INFO:              plotly: 5.14.1
2023-06-19 14:38:20,316:INFO:             kaleido: 0.2.1
2023-06-19 14:38:20,316:INFO:         statsmodels: 0.14.0
2023-06-19 14:38:20,316:INFO:              sktime: 0.17.0
2023-06-19 14:38:20,316:INFO:               tbats: 1.1.3
2023-06-19 14:38:20,316:INFO:            pmdarima: 2.0.3
2023-06-19 14:38:20,316:INFO:              psutil: 5.9.4
2023-06-19 14:38:20,316:INFO:PyCaret optional dependencies:
2023-06-19 14:38:20,318:INFO:                shap: Not installed
2023-06-19 14:38:20,318:INFO:           interpret: Not installed
2023-06-19 14:38:20,318:INFO:                umap: Not installed
2023-06-19 14:38:20,318:INFO:    pandas_profiling: Not installed
2023-06-19 14:38:20,318:INFO:  explainerdashboard: Not installed
2023-06-19 14:38:20,318:INFO:             autoviz: Not installed
2023-06-19 14:38:20,318:INFO:           fairlearn: Not installed
2023-06-19 14:38:20,318:INFO:             xgboost: 1.7.6
2023-06-19 14:38:20,318:INFO:            catboost: Not installed
2023-06-19 14:38:20,318:INFO:              kmodes: Not installed
2023-06-19 14:38:20,318:INFO:             mlxtend: Not installed
2023-06-19 14:38:20,319:INFO:       statsforecast: Not installed
2023-06-19 14:38:20,319:INFO:        tune_sklearn: Not installed
2023-06-19 14:38:20,319:INFO:                 ray: Not installed
2023-06-19 14:38:20,319:INFO:            hyperopt: Not installed
2023-06-19 14:38:20,319:INFO:              optuna: Not installed
2023-06-19 14:38:20,319:INFO:               skopt: Not installed
2023-06-19 14:38:20,320:INFO:              mlflow: Not installed
2023-06-19 14:38:20,320:INFO:              gradio: Not installed
2023-06-19 14:38:20,320:INFO:             fastapi: Not installed
2023-06-19 14:38:20,320:INFO:             uvicorn: Not installed
2023-06-19 14:38:20,320:INFO:              m2cgen: Not installed
2023-06-19 14:38:20,320:INFO:           evidently: Not installed
2023-06-19 14:38:20,320:INFO:               fugue: Not installed
2023-06-19 14:38:20,320:INFO:           streamlit: Not installed
2023-06-19 14:38:20,320:INFO:             prophet: Not installed
2023-06-19 14:38:20,321:INFO:None
2023-06-19 14:38:20,321:INFO:Set up data.
2023-06-19 14:39:31,579:INFO:PyCaret ClassificationExperiment
2023-06-19 14:39:31,579:INFO:Logging name: clf-default-name
2023-06-19 14:39:31,579:INFO:ML Usecase: MLUsecase.CLASSIFICATION
2023-06-19 14:39:31,579:INFO:version 3.0.2
2023-06-19 14:39:31,579:INFO:Initializing setup()
2023-06-19 14:39:31,579:INFO:self.USI: d0d5
2023-06-19 14:39:31,580:INFO:self._variable_keys: {'X', 'n_jobs_param', 'pipeline', 'USI', 'idx', 'log_plots_param', 'y_test', '_available_plots', '_ml_usecase', 'is_multiclass', 'X_test', 'html_param', 'seed', 'gpu_n_jobs_param', 'y_train', 'X_train', 'exp_id', 'logging_param', 'target_param', 'memory', 'fold_groups_param', 'fold_generator', 'data', 'exp_name_log', 'gpu_param', 'fix_imbalance', 'fold_shuffle_param', 'y'}
2023-06-19 14:39:31,580:INFO:Checking environment
2023-06-19 14:39:31,580:INFO:python_version: 3.10.11
2023-06-19 14:39:31,580:INFO:python_build: ('main', 'Apr 20 2023 18:56:50')
2023-06-19 14:39:31,580:INFO:machine: AMD64
2023-06-19 14:39:31,580:INFO:platform: Windows-10-10.0.19041-SP0
2023-06-19 14:39:31,588:INFO:Memory: svmem(total=16901767168, available=1686130688, percent=90.0, used=15215636480, free=1686130688)
2023-06-19 14:39:31,588:INFO:Physical Core: 4
2023-06-19 14:39:31,588:INFO:Logical Core: 8
2023-06-19 14:39:31,588:INFO:Checking libraries
2023-06-19 14:39:31,588:INFO:System:
2023-06-19 14:39:31,589:INFO:    python: 3.10.11 | packaged by Anaconda, Inc. | (main, Apr 20 2023, 18:56:50) [MSC v.1916 64 bit (AMD64)]
2023-06-19 14:39:31,589:INFO:executable: c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\python.exe
2023-06-19 14:39:31,589:INFO:   machine: Windows-10-10.0.19041-SP0
2023-06-19 14:39:31,589:INFO:PyCaret required dependencies:
2023-06-19 14:39:31,589:INFO:                 pip: 23.0.1
2023-06-19 14:39:31,589:INFO:          setuptools: 67.8.0
2023-06-19 14:39:31,589:INFO:             pycaret: 3.0.2
2023-06-19 14:39:31,589:INFO:             IPython: 8.10.0
2023-06-19 14:39:31,589:INFO:          ipywidgets: 8.0.6
2023-06-19 14:39:31,590:INFO:                tqdm: 4.65.0
2023-06-19 14:39:31,590:INFO:               numpy: 1.23.5
2023-06-19 14:39:31,590:INFO:              pandas: 1.5.3
2023-06-19 14:39:31,590:INFO:              jinja2: 3.1.2
2023-06-19 14:39:31,590:INFO:               scipy: 1.10.1
2023-06-19 14:39:31,590:INFO:              joblib: 1.2.0
2023-06-19 14:39:31,590:INFO:             sklearn: 1.2.2
2023-06-19 14:39:31,590:INFO:                pyod: 1.0.9
2023-06-19 14:39:31,590:INFO:            imblearn: 0.10.1
2023-06-19 14:39:31,590:INFO:   category_encoders: 2.6.1
2023-06-19 14:39:31,590:INFO:            lightgbm: 3.3.5
2023-06-19 14:39:31,591:INFO:               numba: 0.57.0
2023-06-19 14:39:31,591:INFO:            requests: 2.31.0
2023-06-19 14:39:31,591:INFO:          matplotlib: 3.7.1
2023-06-19 14:39:31,591:INFO:          scikitplot: 0.3.7
2023-06-19 14:39:31,591:INFO:         yellowbrick: 1.5
2023-06-19 14:39:31,591:INFO:              plotly: 5.14.1
2023-06-19 14:39:31,591:INFO:             kaleido: 0.2.1
2023-06-19 14:39:31,591:INFO:         statsmodels: 0.14.0
2023-06-19 14:39:31,591:INFO:              sktime: 0.17.0
2023-06-19 14:39:31,591:INFO:               tbats: 1.1.3
2023-06-19 14:39:31,591:INFO:            pmdarima: 2.0.3
2023-06-19 14:39:31,592:INFO:              psutil: 5.9.4
2023-06-19 14:39:31,592:INFO:PyCaret optional dependencies:
2023-06-19 14:39:31,592:INFO:                shap: Not installed
2023-06-19 14:39:31,592:INFO:           interpret: Not installed
2023-06-19 14:39:31,592:INFO:                umap: Not installed
2023-06-19 14:39:31,592:INFO:    pandas_profiling: Not installed
2023-06-19 14:39:31,592:INFO:  explainerdashboard: Not installed
2023-06-19 14:39:31,592:INFO:             autoviz: Not installed
2023-06-19 14:39:31,592:INFO:           fairlearn: Not installed
2023-06-19 14:39:31,593:INFO:             xgboost: 1.7.6
2023-06-19 14:39:31,593:INFO:            catboost: Not installed
2023-06-19 14:39:31,593:INFO:              kmodes: Not installed
2023-06-19 14:39:31,593:INFO:             mlxtend: Not installed
2023-06-19 14:39:31,593:INFO:       statsforecast: Not installed
2023-06-19 14:39:31,593:INFO:        tune_sklearn: Not installed
2023-06-19 14:39:31,593:INFO:                 ray: Not installed
2023-06-19 14:39:31,593:INFO:            hyperopt: Not installed
2023-06-19 14:39:31,593:INFO:              optuna: Not installed
2023-06-19 14:39:31,593:INFO:               skopt: Not installed
2023-06-19 14:39:31,593:INFO:              mlflow: Not installed
2023-06-19 14:39:31,594:INFO:              gradio: Not installed
2023-06-19 14:39:31,594:INFO:             fastapi: Not installed
2023-06-19 14:39:31,594:INFO:             uvicorn: Not installed
2023-06-19 14:39:31,594:INFO:              m2cgen: Not installed
2023-06-19 14:39:31,594:INFO:           evidently: Not installed
2023-06-19 14:39:31,594:INFO:               fugue: Not installed
2023-06-19 14:39:31,594:INFO:           streamlit: Not installed
2023-06-19 14:39:31,594:INFO:             prophet: Not installed
2023-06-19 14:39:31,594:INFO:None
2023-06-19 14:39:31,594:INFO:Set up data.
2023-06-19 14:39:53,928:INFO:Set up train/test split.
2023-06-19 14:39:57,436:INFO:Set up index.
2023-06-19 14:39:57,471:INFO:Set up folding strategy.
2023-06-19 14:39:57,471:INFO:Assigning column types.
2023-06-19 14:39:58,860:INFO:Engine successfully changes for model 'lr' to 'sklearn'.
2023-06-19 14:39:59,114:INFO:Engine for model 'knn' has not been set explicitly, hence returning None.
2023-06-19 14:39:59,120:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2023-06-19 14:39:59,329:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 14:39:59,602:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 14:39:59,788:INFO:Engine for model 'knn' has not been set explicitly, hence returning None.
2023-06-19 14:39:59,794:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2023-06-19 14:39:59,929:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 14:39:59,973:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 14:39:59,974:INFO:Engine successfully changes for model 'knn' to 'sklearn'.
2023-06-19 14:40:00,179:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2023-06-19 14:40:00,505:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 14:40:00,513:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 14:40:00,814:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2023-06-19 14:40:00,975:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 14:40:00,988:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 14:40:00,989:INFO:Engine successfully changes for model 'rbfsvm' to 'sklearn'.
2023-06-19 14:40:01,452:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 14:40:01,458:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 14:40:01,825:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 14:40:01,834:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 14:40:01,846:INFO:Preparing preprocessing pipeline...
2023-06-19 14:40:02,162:INFO:Set up label encoding.
2023-06-19 14:40:02,163:INFO:Set up simple imputation.
2023-06-19 14:40:02,163:INFO:Set up imbalanced handling.
2023-06-19 14:40:02,163:INFO:Set up feature normalization.
2023-06-19 14:40:07,201:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 14:40:13,639:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 14:40:27,689:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.05s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 14:40:36,934:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.08s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 14:40:40,743:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 14:41:48,449:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.76s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 14:42:37,311:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 2.29s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 14:42:37,564:INFO:Finished creating preprocessing pipeline.
2023-06-19 14:42:38,731:INFO:Pipeline: Pipeline(memory=FastMemory(location=C:\Users\JOAO~1.COR\AppData\Local\Temp\joblib),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['X_0', 'X_1', 'X_2', 'X_3', 'X_4',
                                             'X_5', 'X_6', 'X_7', 'X_8', 'X_9',
                                             'X_10', 'X_11', 'X_12', 'X_13',
                                             'X_14',...
                                                              strategy='most_frequent',
                                                              verbose='deprecated'))),
                ('balance',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=FixImbalancer(estimator=SMOTE(k_neighbors=5,
                                                                              n_jobs=None,
                                                                              random_state=None,
                                                                              sampling_strategy='auto')))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True)))],
         verbose=False)
2023-06-19 14:42:38,731:INFO:Creating final display dataframe.
2023-06-19 14:48:39,638:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 39.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 14:49:38,437:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 14:49:38,437:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 14:49:38,438:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 14:49:38,438:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 14:49:53,841:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:271: UserWarning: Persisting input arguments took 9.45s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_full_transform(

2023-06-19 14:50:01,854:WARNING:
'prophet' is a soft dependency and not included in the pycaret installation. Please run: `pip install prophet` to install.
2023-06-19 14:50:07,275:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.76s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 14:50:13,376:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.18s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 14:50:17,481:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 14:50:26,422:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:271: UserWarning: Persisting input arguments took 8.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_full_transform(

2023-06-19 14:51:01,363:INFO:Setup _display_container:                     Description  \
0                    Session id   
1                        Target   
2                   Target type   
3                Target mapping   
4           Original data shape   
5        Transformed data shape   
6   Transformed train set shape   
7    Transformed test set shape   
8              Numeric features   
9                    Preprocess   
10              Imputation type   
11           Numeric imputation   
12       Categorical imputation   
13                Fix imbalance   
14         Fix imbalance method   
15                    Normalize   
16             Normalize method   
17               Fold Generator   
18                  Fold Number   
19                     CPU Jobs   
20                      Use GPU   
21               Log Experiment   
22              Experiment Name   
23                          USI   

                                                Value  
0                                                 123  
1                                              target  
2                                          Multiclass  
3   Mild_Demented: 0, Moderate_Demented: 1, Non_De...  
4                                       (4480, 16385)  
5                                       (7616, 16385)  
6                                       (6272, 16385)  
7                                       (1344, 16385)  
8                                               16384  
9                                                True  
10                                             simple  
11                                               mean  
12                                               mode  
13                                               True  
14                                              SMOTE  
15                                               True  
16                                             zscore  
17                                    StratifiedKFold  
18                                                 10  
19                                                 -1  
20                                              False  
21                                              False  
22                                   clf-default-name  
23                                               d0d5  
2023-06-19 14:51:01,907:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 14:51:01,914:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 14:51:02,714:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 14:51:02,727:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 14:51:02,745:INFO:setup() successfully completed in 691.22s...............
2023-06-19 14:53:35,997:INFO:PyCaret ClassificationExperiment
2023-06-19 14:53:35,997:INFO:Logging name: clf-default-name
2023-06-19 14:53:35,998:INFO:ML Usecase: MLUsecase.CLASSIFICATION
2023-06-19 14:53:35,998:INFO:version 3.0.2
2023-06-19 14:53:35,998:INFO:Initializing setup()
2023-06-19 14:53:35,998:INFO:self.USI: 2efd
2023-06-19 14:53:35,998:INFO:self._variable_keys: {'logging_param', 'fix_imbalance', 'is_multiclass', 'X_train', 'USI', '_ml_usecase', 'log_plots_param', 'target_param', 'X_test', 'y_test', 'pipeline', 'fold_generator', 'data', 'exp_id', 'y', 'idx', 'html_param', '_available_plots', 'n_jobs_param', 'gpu_n_jobs_param', 'y_train', 'exp_name_log', 'fold_groups_param', 'memory', 'X', 'fold_shuffle_param', 'gpu_param', 'seed'}
2023-06-19 14:53:35,998:INFO:Checking environment
2023-06-19 14:53:35,998:INFO:python_version: 3.10.11
2023-06-19 14:53:35,998:INFO:python_build: ('main', 'Apr 20 2023 18:56:50')
2023-06-19 14:53:35,998:INFO:machine: AMD64
2023-06-19 14:53:35,999:INFO:platform: Windows-10-10.0.19045-SP0
2023-06-19 14:53:36,008:INFO:Memory: svmem(total=16901767168, available=3376271360, percent=80.0, used=13525495808, free=3376271360)
2023-06-19 14:53:36,008:INFO:Physical Core: 4
2023-06-19 14:53:36,009:INFO:Logical Core: 8
2023-06-19 14:53:36,009:INFO:Checking libraries
2023-06-19 14:53:36,009:INFO:System:
2023-06-19 14:53:36,009:INFO:    python: 3.10.11 | packaged by Anaconda, Inc. | (main, Apr 20 2023, 18:56:50) [MSC v.1916 64 bit (AMD64)]
2023-06-19 14:53:36,009:INFO:executable: c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\python.exe
2023-06-19 14:53:36,009:INFO:   machine: Windows-10-10.0.19045-SP0
2023-06-19 14:53:36,009:INFO:PyCaret required dependencies:
2023-06-19 14:53:36,009:INFO:                 pip: 23.0.1
2023-06-19 14:53:36,009:INFO:          setuptools: 67.8.0
2023-06-19 14:53:36,010:INFO:             pycaret: 3.0.2
2023-06-19 14:53:36,010:INFO:             IPython: 8.10.0
2023-06-19 14:53:36,010:INFO:          ipywidgets: 8.0.6
2023-06-19 14:53:36,010:INFO:                tqdm: 4.65.0
2023-06-19 14:53:36,010:INFO:               numpy: 1.23.5
2023-06-19 14:53:36,010:INFO:              pandas: 1.5.3
2023-06-19 14:53:36,010:INFO:              jinja2: 3.1.2
2023-06-19 14:53:36,010:INFO:               scipy: 1.10.1
2023-06-19 14:53:36,010:INFO:              joblib: 1.2.0
2023-06-19 14:53:36,010:INFO:             sklearn: 1.2.2
2023-06-19 14:53:36,010:INFO:                pyod: 1.0.9
2023-06-19 14:53:36,011:INFO:            imblearn: 0.10.1
2023-06-19 14:53:36,011:INFO:   category_encoders: 2.6.1
2023-06-19 14:53:36,011:INFO:            lightgbm: 3.3.5
2023-06-19 14:53:36,011:INFO:               numba: 0.57.0
2023-06-19 14:53:36,011:INFO:            requests: 2.31.0
2023-06-19 14:53:36,011:INFO:          matplotlib: 3.7.1
2023-06-19 14:53:36,011:INFO:          scikitplot: 0.3.7
2023-06-19 14:53:36,011:INFO:         yellowbrick: 1.5
2023-06-19 14:53:36,011:INFO:              plotly: 5.14.1
2023-06-19 14:53:36,011:INFO:             kaleido: 0.2.1
2023-06-19 14:53:36,011:INFO:         statsmodels: 0.14.0
2023-06-19 14:53:36,012:INFO:              sktime: 0.17.0
2023-06-19 14:53:36,012:INFO:               tbats: 1.1.3
2023-06-19 14:53:36,012:INFO:            pmdarima: 2.0.3
2023-06-19 14:53:36,012:INFO:              psutil: 5.9.4
2023-06-19 14:53:36,012:INFO:PyCaret optional dependencies:
2023-06-19 14:53:36,123:INFO:                shap: Not installed
2023-06-19 14:53:36,124:INFO:           interpret: Not installed
2023-06-19 14:53:36,124:INFO:                umap: Not installed
2023-06-19 14:53:36,124:INFO:    pandas_profiling: Not installed
2023-06-19 14:53:36,124:INFO:  explainerdashboard: Not installed
2023-06-19 14:53:36,124:INFO:             autoviz: Not installed
2023-06-19 14:53:36,124:INFO:           fairlearn: Not installed
2023-06-19 14:53:36,124:INFO:             xgboost: 1.7.6
2023-06-19 14:53:36,124:INFO:            catboost: Not installed
2023-06-19 14:53:36,124:INFO:              kmodes: Not installed
2023-06-19 14:53:36,124:INFO:             mlxtend: Not installed
2023-06-19 14:53:36,124:INFO:       statsforecast: Not installed
2023-06-19 14:53:36,125:INFO:        tune_sklearn: Not installed
2023-06-19 14:53:36,125:INFO:                 ray: Not installed
2023-06-19 14:53:36,125:INFO:            hyperopt: Not installed
2023-06-19 14:53:36,125:INFO:              optuna: Not installed
2023-06-19 14:53:36,125:INFO:               skopt: Not installed
2023-06-19 14:53:36,125:INFO:              mlflow: Not installed
2023-06-19 14:53:36,125:INFO:              gradio: Not installed
2023-06-19 14:53:36,125:INFO:             fastapi: Not installed
2023-06-19 14:53:36,125:INFO:             uvicorn: Not installed
2023-06-19 14:53:36,125:INFO:              m2cgen: Not installed
2023-06-19 14:53:36,125:INFO:           evidently: Not installed
2023-06-19 14:53:36,125:INFO:               fugue: Not installed
2023-06-19 14:53:36,126:INFO:           streamlit: Not installed
2023-06-19 14:53:36,126:INFO:             prophet: Not installed
2023-06-19 14:53:36,126:INFO:None
2023-06-19 14:53:36,126:INFO:Set up data.
2023-06-19 15:39:54,930:INFO:Initializing compare_models()
2023-06-19 15:39:54,930:INFO:compare_models(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000226BAA69ED0>, include=None, fold=None, round=4, cross_validation=True, sort=F1, n_select=1, budget_time=None, turbo=True, errors=ignore, fit_kwargs=None, groups=None, experiment_custom_tags=None, probability_threshold=None, verbose=True, parallel=None, caller_params={'self': <pycaret.classification.oop.ClassificationExperiment object at 0x00000226BAA69ED0>, 'include': None, 'exclude': None, 'fold': None, 'round': 4, 'cross_validation': True, 'sort': 'F1', 'n_select': 1, 'budget_time': None, 'turbo': True, 'errors': 'ignore', 'fit_kwargs': None, 'groups': None, 'experiment_custom_tags': None, 'probability_threshold': None, 'engine': None, 'verbose': True, 'parallel': None, '__class__': <class 'pycaret.classification.oop.ClassificationExperiment'>}, exclude=None)
2023-06-19 15:39:54,931:INFO:Checking exceptions
2023-06-19 15:39:57,251:INFO:Preparing display monitor
2023-06-19 15:39:57,390:INFO:Initializing Logistic Regression
2023-06-19 15:39:57,391:INFO:Total runtime is 1.666545867919922e-05 minutes
2023-06-19 15:39:57,399:INFO:SubProcess create_model() called ==================================
2023-06-19 15:39:57,400:INFO:Initializing create_model()
2023-06-19 15:39:57,414:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000226BAA69ED0>, estimator=lr, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000226841BFAF0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 15:39:57,415:INFO:Checking exceptions
2023-06-19 15:39:57,415:INFO:Importing libraries
2023-06-19 15:39:57,415:INFO:Copying training dataset
2023-06-19 15:40:02,213:INFO:Defining folds
2023-06-19 15:40:02,213:INFO:Declaring metric variables
2023-06-19 15:40:02,233:INFO:Importing untrained model
2023-06-19 15:40:02,274:INFO:Logistic Regression Imported successfully
2023-06-19 15:40:02,293:INFO:Starting cross validation
2023-06-19 15:40:03,322:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 15:41:23,833:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.14s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:41:29,973:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.46s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:41:29,973:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.35s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:41:30,020:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.36s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:41:30,883:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:41:48,321:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.10s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:41:48,631:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.44s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:41:48,830:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:41:49,095:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:41:50,249:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:41:53,746:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:41:56,406:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.76s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:41:59,646:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:41:59,649:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:42:00,626:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:42:12,725:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:42:12,780:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:42:12,928:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:42:12,983:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:42:13,051:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:42:13,147:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:42:14,109:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:42:14,642:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.23s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:42:14,645:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.01s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:42:14,797:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.40s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:42:14,800:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:42:14,813:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.14s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:42:16,284:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.77s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:42:16,878:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:42:18,483:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:42:28,326:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:42:30,469:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:42:30,999:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:42:38,350:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:42:44,851:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.85s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:42:46,924:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:43:00,918:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:48:01,151:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 15:48:02,904:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 15:48:05,317:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.32s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:48:08,859:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:48:08,882:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:48:08,888:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:48:33,185:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 15:48:37,018:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 15:48:38,583:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 15:48:40,109:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.41s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:48:42,188:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:48:42,191:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:48:42,194:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:48:42,353:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
8 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 231, in _fit
    fitted_transformer = self._memory_fit(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 66, in _fit_one
    transformer.fit(*args, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 224, in fit
    args.append(X[self._include])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 3819, in __getitem__
    data = self._take_with_is_copy(indexer, axis=1)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3902, in _take_with_is_copy
    result = self._take(indices=indices, axis=axis)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3886, in _take
    new_data = self._mgr.take(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 978, in take
    return self.reindex_indexer(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 743, in reindex_indexer
    new_blocks, new_refs = self._slice_take_blocks_ax0(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 912, in _slice_take_blocks_ax0
    nb = blk.take_nd(taker, axis=0, new_mgr_locs=mgr_locs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 880, in take_nd
    new_values = algos.take_nd(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 117, in take_nd
    return _take_nd_ndarray(arr, indexer, axis, fill_value, allow_fill)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 158, in _take_nd_ndarray
    out = np.empty(out_shape, dtype=dtype)
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (16384, 2822) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 247, in transform
    args.append(X[self._include])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 3819, in __getitem__
    data = self._take_with_is_copy(indexer, axis=1)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3902, in _take_with_is_copy
    result = self._take(indices=indices, axis=axis)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3886, in _take
    new_data = self._mgr.take(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 978, in take
    return self.reindex_indexer(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 743, in reindex_indexer
    new_blocks, new_refs = self._slice_take_blocks_ax0(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 912, in _slice_take_blocks_ax0
    nb = blk.take_nd(taker, axis=0, new_mgr_locs=mgr_locs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 880, in take_nd
    new_values = algos.take_nd(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 117, in take_nd
    return _take_nd_ndarray(arr, indexer, axis, fill_value, allow_fill)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 158, in _take_nd_ndarray
    out = np.empty(out_shape, dtype=dtype)
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (16384, 2822) and data type float64

--------------------------------------------------------------------------------
3 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 232, in transform
    X = to_df(X, index=getattr(y, "index", None))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\utils\generic.py", line 109, in to_df
    data = data.rename(columns=lambda col: str(col))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 5573, in rename
    return super()._rename(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 1077, in _rename
    result = self if inplace else self.copy(deep=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6368, in copy
    data = self._mgr.copy(deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 649, in copy
    res = self.apply("copy", deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 549, in copy
    values = values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (16384, 2822) and data type float64

--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 154, in _generate_samples
    diffs = nn_data[nn_num[rows, cols]] - X[rows]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (1020, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 232, in transform
    X = to_df(X, index=getattr(y, "index", None))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\utils\generic.py", line 109, in to_df
    data = data.rename(columns=lambda col: str(col))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 5573, in rename
    return super()._rename(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 1077, in _rename
    result = self if inplace else self.copy(deep=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6368, in copy
    data = self._mgr.copy(deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 649, in copy
    res = self.apply("copy", deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 549, in copy
    values = values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (16384, 2823) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 15:48:42,377:INFO:Calculating mean and std
2023-06-19 15:48:42,431:INFO:Creating metrics dataframe
2023-06-19 15:48:42,554:INFO:Uploading results into container
2023-06-19 15:48:42,559:INFO:Uploading model into container now
2023-06-19 15:48:42,570:INFO:_master_model_container: 1
2023-06-19 15:48:42,570:INFO:_display_container: 2
2023-06-19 15:48:42,578:INFO:LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                   intercept_scaling=1, l1_ratio=None, max_iter=1000,
                   multi_class='auto', n_jobs=None, penalty='l2',
                   random_state=123, solver='lbfgs', tol=0.0001, verbose=0,
                   warm_start=False)
2023-06-19 15:48:42,578:INFO:create_model() successfully completed......................................
2023-06-19 15:48:44,091:WARNING:create_model() for LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                   intercept_scaling=1, l1_ratio=None, max_iter=1000,
                   multi_class='auto', n_jobs=None, penalty='l2',
                   random_state=123, solver='lbfgs', tol=0.0001, verbose=0,
                   warm_start=False) raised an exception or returned all 0.0, trying without fit_kwargs:
2023-06-19 15:48:44,097:WARNING:Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 795, in compare_models
    np.sum(
AssertionError

2023-06-19 15:48:44,097:INFO:Initializing create_model()
2023-06-19 15:48:44,097:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000226BAA69ED0>, estimator=lr, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000226841BFAF0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 15:48:44,097:INFO:Checking exceptions
2023-06-19 15:48:44,097:INFO:Importing libraries
2023-06-19 15:48:44,098:INFO:Copying training dataset
2023-06-19 15:48:45,919:INFO:Defining folds
2023-06-19 15:48:45,919:INFO:Declaring metric variables
2023-06-19 15:48:45,928:INFO:Importing untrained model
2023-06-19 15:48:45,933:INFO:Logistic Regression Imported successfully
2023-06-19 15:48:45,940:INFO:Starting cross validation
2023-06-19 15:48:46,483:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 15:48:51,719:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:48:51,782:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.76s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:49:07,599:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:49:27,617:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:49:42,591:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:49:42,755:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.00s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:49:45,188:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:50:02,120:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:49:44,146:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:50:10,778:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:49:43,804:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:50:10,997:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:50:21,066:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:50:21,347:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:50:24,641:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:50:30,829:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.35s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:50:34,595:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:50:37,909:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 1.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:50:38,120:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:50:38,165:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:50:38,168:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:53:19,476:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 0.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:53:22,861:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 0.82s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:53:22,994:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:53:22,997:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:53:22,999:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:53:23,147:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
8 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\preprocessing\_data.py", line 992, in transform
    X = self._validate_data(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\base.py", line 565, in _validate_data
    X = check_array(X, input_name="X", **check_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\validation.py", line 950, in check_array
    array = _asarray_with_order(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_array_api.py", line 186, in _asarray_with_order
    return xp.asarray(array, copy=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_array_api.py", line 73, in asarray
    return numpy.array(x, copy=True, dtype=dtype)
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (5648, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 231, in _fit
    fitted_transformer = self._memory_fit(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 66, in _fit_one
    transformer.fit(*args, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 224, in fit
    args.append(X[self._include])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 3819, in __getitem__
    data = self._take_with_is_copy(indexer, axis=1)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3902, in _take_with_is_copy
    result = self._take(indices=indices, axis=axis)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3884, in _take
    self._consolidate_inplace()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 5980, in _consolidate_inplace
    self._protect_consolidate(f)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 5968, in _protect_consolidate
    result = f()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 5978, in f
    self._mgr = self._mgr.consolidate()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 686, in consolidate
    bm._consolidate_inplace()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 1871, in _consolidate_inplace
    self.blocks = _consolidate(self.blocks)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 2329, in _consolidate
    merged_blocks, _ = _merge_blocks(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 2388, in _merge_blocks
    new_values = new_values[argsort]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (16384, 5648) and data type float64

--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 262, in transform
    new_X = self._prepare_df(X, output)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 191, in _prepare_df
    out = to_df(out, index=X.index, columns=columns)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\utils\generic.py", line 109, in to_df
    data = data.rename(columns=lambda col: str(col))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 5573, in rename
    return super()._rename(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 1077, in _rename
    result = self if inplace else self.copy(deep=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6368, in copy
    data = self._mgr.copy(deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 649, in copy
    res = self.apply("copy", deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 549, in copy
    values = values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (16384, 2822) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\impute\_base.py", line 551, in transform
    X = self._validate_input(X, in_fit=False)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\impute\_base.py", line 327, in _validate_input
    X = self._validate_data(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\base.py", line 565, in _validate_data
    X = check_array(X, input_name="X", **check_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\validation.py", line 879, in check_array
    array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_array_api.py", line 185, in _asarray_with_order
    array = numpy.asarray(array, order=order, dtype=dtype)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 2070, in __array__
    return np.asarray(self._values, dtype=dtype)
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (2822, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\preprocessing\_data.py", line 992, in transform
    X = self._validate_data(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\base.py", line 565, in _validate_data
    X = check_array(X, input_name="X", **check_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\validation.py", line 950, in check_array
    array = _asarray_with_order(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_array_api.py", line 186, in _asarray_with_order
    return xp.asarray(array, copy=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_array_api.py", line 73, in asarray
    return numpy.array(x, copy=True, dtype=dtype)
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (5644, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 262, in transform
    new_X = self._prepare_df(X, output)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 191, in _prepare_df
    out = to_df(out, index=X.index, columns=columns)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\utils\generic.py", line 109, in to_df
    data = data.rename(columns=lambda col: str(col))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 5573, in rename
    return super()._rename(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 1077, in _rename
    result = self if inplace else self.copy(deep=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6368, in copy
    data = self._mgr.copy(deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 649, in copy
    res = self.apply("copy", deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 549, in copy
    values = values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (16384, 2823) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 232, in transform
    X = to_df(X, index=getattr(y, "index", None))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\utils\generic.py", line 109, in to_df
    data = data.rename(columns=lambda col: str(col))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 5573, in rename
    return super()._rename(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 1077, in _rename
    result = self if inplace else self.copy(deep=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6368, in copy
    data = self._mgr.copy(deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 670, in copy
    res._consolidate_inplace()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 1871, in _consolidate_inplace
    self.blocks = _consolidate(self.blocks)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 2329, in _consolidate
    merged_blocks, _ = _merge_blocks(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 2388, in _merge_blocks
    new_values = new_values[argsort]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (16384, 5644) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 15:53:23,168:INFO:Calculating mean and std
2023-06-19 15:53:23,238:INFO:Creating metrics dataframe
2023-06-19 15:53:23,433:INFO:Uploading results into container
2023-06-19 15:53:23,440:INFO:Uploading model into container now
2023-06-19 15:53:23,453:INFO:_master_model_container: 2
2023-06-19 15:53:23,453:INFO:_display_container: 2
2023-06-19 15:53:23,464:INFO:LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                   intercept_scaling=1, l1_ratio=None, max_iter=1000,
                   multi_class='auto', n_jobs=None, penalty='l2',
                   random_state=123, solver='lbfgs', tol=0.0001, verbose=0,
                   warm_start=False)
2023-06-19 15:53:23,465:INFO:create_model() successfully completed......................................
2023-06-19 15:53:24,971:ERROR:create_model() for LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                   intercept_scaling=1, l1_ratio=None, max_iter=1000,
                   multi_class='auto', n_jobs=None, penalty='l2',
                   random_state=123, solver='lbfgs', tol=0.0001, verbose=0,
                   warm_start=False) raised an exception or returned all 0.0:
2023-06-19 15:53:24,972:ERROR:Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 795, in compare_models
    np.sum(
AssertionError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 811, in compare_models
    np.sum(
AssertionError

2023-06-19 15:53:24,972:INFO:Initializing K Neighbors Classifier
2023-06-19 15:53:24,972:INFO:Total runtime is 13.459695478280384 minutes
2023-06-19 15:53:24,977:INFO:SubProcess create_model() called ==================================
2023-06-19 15:53:24,977:INFO:Initializing create_model()
2023-06-19 15:53:24,978:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000226BAA69ED0>, estimator=knn, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000226841BFAF0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 15:53:24,978:INFO:Checking exceptions
2023-06-19 15:53:24,978:INFO:Importing libraries
2023-06-19 15:53:24,978:INFO:Copying training dataset
2023-06-19 15:53:26,085:INFO:Defining folds
2023-06-19 15:53:26,085:INFO:Declaring metric variables
2023-06-19 15:53:26,090:INFO:Importing untrained model
2023-06-19 15:53:26,095:INFO:K Neighbors Classifier Imported successfully
2023-06-19 15:53:26,102:INFO:Starting cross validation
2023-06-19 15:53:26,696:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 15:53:32,987:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.05s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:53:33,138:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.13s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:53:33,431:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.21s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:49:47,130:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:53:33,506:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.00s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:49:43,438:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:53:33,550:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.07s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:53:33,624:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.05s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:53:34,354:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:53:34,618:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:53:35,103:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:53:35,183:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:53:35,526:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:53:35,862:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.23s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:54:07,479:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.25s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:54:11,604:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:54:15,633:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:54:17,358:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:54:17,362:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:54:17,365:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:54:17,718:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
9 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 345, in _fit_resample
    X_resampled = [X.copy()]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (2822, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 365, in _fit_resample
    X_resampled = np.vstack(X_resampled)
  File "<__array_function__ internals>", line 180, in vstack
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\numpy\core\shape_base.py", line 282, in vstack
    return _nx.concatenate(arrs, 0)
  File "<__array_function__ internals>", line 180, in concatenate
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (5648, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 161, in _generate_samples
    X_new = X[rows] + steps * diffs
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (1021, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 365, in _fit_resample
    X_resampled = np.vstack(X_resampled)
  File "<__array_function__ internals>", line 180, in vstack
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\numpy\core\shape_base.py", line 282, in vstack
    return _nx.concatenate(arrs, 0)
  File "<__array_function__ internals>", line 180, in concatenate
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (5644, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 154, in _generate_samples
    diffs = nn_data[nn_num[rows, cols]] - X[rows]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 173. MiB for an array with shape (1383, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 247, in transform
    args.append(X[self._include])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 3819, in __getitem__
    data = self._take_with_is_copy(indexer, axis=1)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3902, in _take_with_is_copy
    result = self._take(indices=indices, axis=axis)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3886, in _take
    new_data = self._mgr.take(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 978, in take
    return self.reindex_indexer(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 743, in reindex_indexer
    new_blocks, new_refs = self._slice_take_blocks_ax0(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 912, in _slice_take_blocks_ax0
    nb = blk.take_nd(taker, axis=0, new_mgr_locs=mgr_locs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 880, in take_nd
    new_values = algos.take_nd(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 117, in take_nd
    return _take_nd_ndarray(arr, indexer, axis, fill_value, allow_fill)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 158, in _take_nd_ndarray
    out = np.empty(out_shape, dtype=dtype)
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (16384, 2823) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 345, in _fit_resample
    X_resampled = [X.copy()]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (2823, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 232, in transform
    X = to_df(X, index=getattr(y, "index", None))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\utils\generic.py", line 109, in to_df
    data = data.rename(columns=lambda col: str(col))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 5573, in rename
    return super()._rename(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 1077, in _rename
    result = self if inplace else self.copy(deep=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6368, in copy
    data = self._mgr.copy(deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 649, in copy
    res = self.apply("copy", deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 549, in copy
    values = values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 44.1 MiB for an array with shape (16384, 2823) and data type uint8

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 15:54:17,727:INFO:Calculating mean and std
2023-06-19 15:54:17,758:INFO:Creating metrics dataframe
2023-06-19 15:54:17,879:INFO:Uploading results into container
2023-06-19 15:54:17,884:INFO:Uploading model into container now
2023-06-19 15:54:17,893:INFO:_master_model_container: 3
2023-06-19 15:54:17,893:INFO:_display_container: 2
2023-06-19 15:54:17,900:INFO:KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',
                     metric_params=None, n_jobs=-1, n_neighbors=5, p=2,
                     weights='uniform')
2023-06-19 15:54:17,900:INFO:create_model() successfully completed......................................
2023-06-19 15:54:19,121:WARNING:create_model() for KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',
                     metric_params=None, n_jobs=-1, n_neighbors=5, p=2,
                     weights='uniform') raised an exception or returned all 0.0, trying without fit_kwargs:
2023-06-19 15:54:19,122:WARNING:Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 795, in compare_models
    np.sum(
AssertionError

2023-06-19 15:54:19,122:INFO:Initializing create_model()
2023-06-19 15:54:19,122:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000226BAA69ED0>, estimator=knn, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000226841BFAF0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 15:54:19,122:INFO:Checking exceptions
2023-06-19 15:54:19,122:INFO:Importing libraries
2023-06-19 15:54:19,123:INFO:Copying training dataset
2023-06-19 15:54:20,267:INFO:Defining folds
2023-06-19 15:54:20,268:INFO:Declaring metric variables
2023-06-19 15:54:20,273:INFO:Importing untrained model
2023-06-19 15:54:20,280:INFO:K Neighbors Classifier Imported successfully
2023-06-19 15:54:20,294:INFO:Starting cross validation
2023-06-19 15:54:20,597:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 15:54:21,271:ERROR:create_model() for KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',
                     metric_params=None, n_jobs=-1, n_neighbors=5, p=2,
                     weights='uniform') raised an exception or returned all 0.0:
2023-06-19 15:54:21,280:ERROR:joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\queues.py", line 125, in _feed
    obj_ = dumps(obj, reducers=reducers)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 211, in dumps
    dump(obj, buf, reducers=reducers, protocol=protocol)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 204, in dump
    _LokyPickler(file, reducers=reducers, protocol=protocol).dump(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\cloudpickle\cloudpickle_fast.py", line 632, in dump
    return Pickler.dump(self, obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_memmapping_reducer.py", line 446, in __call__
    for dumped_filename in dump(a, filename):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 553, in dump
    NumpyPickler(f, protocol=protocol).dump(value)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\pickle.py", line 487, in dump
    self.save(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 352, in save
    wrapper.write_array(obj, self)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 134, in write_array
    pickler.file_handle.write(chunk.tobytes('C'))
OSError: [Errno 28] No space left on device
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 808, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1519, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1114, in _create_model_with_cv
    scores = cross_validate(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 266, in cross_validate
    results = parallel(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\parallel.py", line 63, in __call__
    return super().__call__(iterable_with_config)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 1098, in __call__
    self.retrieve()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 975, in retrieve
    self._output.extend(job.get(timeout=self.timeout))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_parallel_backends.py", line 567, in wrap_future_result
    return future.result(timeout=timeout)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 458, in result
    return self.__get_result()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 403, in __get_result
    raise self._exception
_pickle.PicklingError: Could not pickle the task to send it to the workers.

2023-06-19 15:54:21,281:INFO:Initializing Naive Bayes
2023-06-19 15:54:21,281:INFO:Total runtime is 14.398183278242746 minutes
2023-06-19 15:54:21,286:INFO:SubProcess create_model() called ==================================
2023-06-19 15:54:21,286:INFO:Initializing create_model()
2023-06-19 15:54:21,286:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000226BAA69ED0>, estimator=nb, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000226841BFAF0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 15:54:21,287:INFO:Checking exceptions
2023-06-19 15:54:21,288:INFO:Importing libraries
2023-06-19 15:54:21,288:INFO:Copying training dataset
2023-06-19 15:54:22,475:INFO:Defining folds
2023-06-19 15:54:22,476:INFO:Declaring metric variables
2023-06-19 15:54:22,480:INFO:Importing untrained model
2023-06-19 15:54:22,486:INFO:Naive Bayes Imported successfully
2023-06-19 15:54:22,494:INFO:Starting cross validation
2023-06-19 15:54:22,643:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 15:54:37,375:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.23s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:54:37,381:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.26s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:54:37,412:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.14s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:54:37,477:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.23s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:54:37,500:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:54:37,889:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.40s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:54:39,191:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:54:39,214:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:54:39,333:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:54:39,369:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:54:39,439:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:54:39,717:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:54:51,889:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:54:59,859:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.05s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:55:10,708:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:55:17,556:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 15:55:19,982:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.34s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:55:20,332:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 5.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:55:20,439:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 5.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:55:24,173:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 15:55:24,605:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 15:55:24,728:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 15:55:26,904:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 2.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:55:27,386:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:55:27,390:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:55:27,394:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:55:29,718:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:55:29,769:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:55:33,797:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 1.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:55:33,878:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 1.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:55:34,244:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:55:34,249:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:55:34,253:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:55:34,333:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:55:34,337:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:55:34,340:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:55:34,584:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
7 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 345, in _fit_resample
    X_resampled = [X.copy()]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (2822, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 365, in _fit_resample
    X_resampled = np.vstack(X_resampled)
  File "<__array_function__ internals>", line 180, in vstack
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\numpy\core\shape_base.py", line 282, in vstack
    return _nx.concatenate(arrs, 0)
  File "<__array_function__ internals>", line 180, in concatenate
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (5648, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 247, in transform
    args.append(X[self._include])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 3819, in __getitem__
    data = self._take_with_is_copy(indexer, axis=1)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3902, in _take_with_is_copy
    result = self._take(indices=indices, axis=axis)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3886, in _take
    new_data = self._mgr.take(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 978, in take
    return self.reindex_indexer(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 743, in reindex_indexer
    new_blocks, new_refs = self._slice_take_blocks_ax0(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 912, in _slice_take_blocks_ax0
    nb = blk.take_nd(taker, axis=0, new_mgr_locs=mgr_locs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 880, in take_nd
    new_values = algos.take_nd(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 117, in take_nd
    return _take_nd_ndarray(arr, indexer, axis, fill_value, allow_fill)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 158, in _take_nd_ndarray
    out = np.empty(out_shape, dtype=dtype)
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (16384, 2822) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 161, in _generate_samples
    X_new = X[rows] + steps * diffs
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (1020, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 352, in _fit_resample
    X_class = _safe_indexing(X, target_class_indices)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\__init__.py", line 356, in _safe_indexing
    return _array_indexing(X, indices, indices_dtype, axis=axis)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\__init__.py", line 185, in _array_indexing
    return array[key] if axis == 0 else array[:, key]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 48.9 MiB for an array with shape (391, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 161, in _generate_samples
    X_new = X[rows] + steps * diffs
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 52.4 MiB for an array with shape (419, 16384) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 15:55:34,603:INFO:Calculating mean and std
2023-06-19 15:55:34,653:INFO:Creating metrics dataframe
2023-06-19 15:55:34,775:INFO:Uploading results into container
2023-06-19 15:55:34,779:INFO:Uploading model into container now
2023-06-19 15:55:34,787:INFO:_master_model_container: 4
2023-06-19 15:55:34,788:INFO:_display_container: 2
2023-06-19 15:55:34,794:INFO:GaussianNB(priors=None, var_smoothing=1e-09)
2023-06-19 15:55:34,794:INFO:create_model() successfully completed......................................
2023-06-19 15:55:36,024:WARNING:create_model() for GaussianNB(priors=None, var_smoothing=1e-09) raised an exception or returned all 0.0, trying without fit_kwargs:
2023-06-19 15:55:36,024:WARNING:Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 795, in compare_models
    np.sum(
AssertionError

2023-06-19 15:55:36,024:INFO:Initializing create_model()
2023-06-19 15:55:36,024:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000226BAA69ED0>, estimator=nb, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000226841BFAF0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 15:55:36,025:INFO:Checking exceptions
2023-06-19 15:55:36,025:INFO:Importing libraries
2023-06-19 15:55:36,025:INFO:Copying training dataset
2023-06-19 15:55:37,113:INFO:Defining folds
2023-06-19 15:55:37,113:INFO:Declaring metric variables
2023-06-19 15:55:37,120:INFO:Importing untrained model
2023-06-19 15:55:37,125:INFO:Naive Bayes Imported successfully
2023-06-19 15:55:37,136:INFO:Starting cross validation
2023-06-19 15:55:37,952:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 15:55:43,884:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:55:44,050:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:55:44,052:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:55:44,177:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.18s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:55:44,222:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:55:44,431:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.26s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:55:45,350:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.76s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:55:45,553:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:55:45,773:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:55:45,807:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:55:45,917:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.89s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:55:46,317:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:55:55,699:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:00,936:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:04,666:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:07,178:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:56:10,191:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:13,381:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:56:16,211:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:17,256:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 15:56:18,691:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 15:56:20,638:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:56:23,015:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 15:56:24,307:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 15:56:26,329:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:56:27,248:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 1.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:56:27,732:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:56:27,736:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:56:27,742:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:56:30,048:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 5.36s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:30,051:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 5.33s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:31,645:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 1.44s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:56:32,128:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:56:32,132:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:56:32,137:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:56:36,735:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.18s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:56:36,751:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:56:39,889:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 1.05s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:56:39,889:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 1.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:56:40,244:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:56:40,246:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:56:40,247:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:56:40,249:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:56:40,250:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:56:40,252:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:56:40,338:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
6 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 161, in _generate_samples
    X_new = X[rows] + steps * diffs
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (1022, 16384) and data type float64

--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 247, in transform
    args.append(X[self._include])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 3819, in __getitem__
    data = self._take_with_is_copy(indexer, axis=1)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3902, in _take_with_is_copy
    result = self._take(indices=indices, axis=axis)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3886, in _take
    new_data = self._mgr.take(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 978, in take
    return self.reindex_indexer(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 743, in reindex_indexer
    new_blocks, new_refs = self._slice_take_blocks_ax0(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 912, in _slice_take_blocks_ax0
    nb = blk.take_nd(taker, axis=0, new_mgr_locs=mgr_locs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 880, in take_nd
    new_values = algos.take_nd(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 117, in take_nd
    return _take_nd_ndarray(arr, indexer, axis, fill_value, allow_fill)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 158, in _take_nd_ndarray
    out = np.empty(out_shape, dtype=dtype)
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (16384, 2822) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 345, in _fit_resample
    X_resampled = [X.copy()]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (2822, 16384) and data type float64

--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 345, in _fit_resample
    X_resampled = [X.copy()]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (2823, 16384) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 15:56:40,351:INFO:Calculating mean and std
2023-06-19 15:56:40,396:INFO:Creating metrics dataframe
2023-06-19 15:56:40,565:INFO:Uploading results into container
2023-06-19 15:56:40,570:INFO:Uploading model into container now
2023-06-19 15:56:40,576:INFO:_master_model_container: 5
2023-06-19 15:56:40,577:INFO:_display_container: 2
2023-06-19 15:56:40,582:INFO:GaussianNB(priors=None, var_smoothing=1e-09)
2023-06-19 15:56:40,583:INFO:create_model() successfully completed......................................
2023-06-19 15:56:42,321:ERROR:create_model() for GaussianNB(priors=None, var_smoothing=1e-09) raised an exception or returned all 0.0:
2023-06-19 15:56:42,321:ERROR:Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 795, in compare_models
    np.sum(
AssertionError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 811, in compare_models
    np.sum(
AssertionError

2023-06-19 15:56:42,321:INFO:Initializing Decision Tree Classifier
2023-06-19 15:56:42,321:INFO:Total runtime is 16.74884994427363 minutes
2023-06-19 15:56:42,326:INFO:SubProcess create_model() called ==================================
2023-06-19 15:56:42,326:INFO:Initializing create_model()
2023-06-19 15:56:42,326:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000226BAA69ED0>, estimator=dt, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000226841BFAF0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 15:56:42,326:INFO:Checking exceptions
2023-06-19 15:56:42,326:INFO:Importing libraries
2023-06-19 15:56:42,328:INFO:Copying training dataset
2023-06-19 15:56:43,319:INFO:Defining folds
2023-06-19 15:56:43,319:INFO:Declaring metric variables
2023-06-19 15:56:43,418:INFO:Importing untrained model
2023-06-19 15:56:43,423:INFO:Decision Tree Classifier Imported successfully
2023-06-19 15:56:43,435:INFO:Starting cross validation
2023-06-19 15:56:43,638:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 15:56:49,341:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.17s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:49,771:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:49,811:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:49,828:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:50,126:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.22s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:50,207:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:51,179:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:51,547:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:51,595:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:51,911:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:52,194:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.20s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:52,453:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.99s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:56:59,464:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:57:09,853:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:57:11,318:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:57:19,432:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:57:21,581:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 15:57:25,185:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:57:29,668:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 5.34s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:58:43,954:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.42s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:58:44,167:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.48s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:58:47,355:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 1.27s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:58:47,518:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:58:47,522:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:58:47,526:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:58:48,485:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 0.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 15:58:48,617:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:58:48,620:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:58:48,623:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 15:58:48,639:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
8 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 232, in transform
    X = to_df(X, index=getattr(y, "index", None))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\utils\generic.py", line 109, in to_df
    data = data.rename(columns=lambda col: str(col))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 5573, in rename
    return super()._rename(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 1077, in _rename
    result = self if inplace else self.copy(deep=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6368, in copy
    data = self._mgr.copy(deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 649, in copy
    res = self.apply("copy", deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 549, in copy
    values = values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (16384, 5648) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 365, in _fit_resample
    X_resampled = np.vstack(X_resampled)
  File "<__array_function__ internals>", line 180, in vstack
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\numpy\core\shape_base.py", line 282, in vstack
    return _nx.concatenate(arrs, 0)
  File "<__array_function__ internals>", line 180, in concatenate
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (5648, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 345, in _fit_resample
    X_resampled = [X.copy()]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (2822, 16384) and data type float64

--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 232, in transform
    X = to_df(X, index=getattr(y, "index", None))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\utils\generic.py", line 109, in to_df
    data = data.rename(columns=lambda col: str(col))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 5573, in rename
    return super()._rename(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 1077, in _rename
    result = self if inplace else self.copy(deep=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6368, in copy
    data = self._mgr.copy(deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 649, in copy
    res = self.apply("copy", deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 549, in copy
    values = values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (16384, 2822) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 154, in _generate_samples
    diffs = nn_data[nn_num[rows, cols]] - X[rows]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 173. MiB for an array with shape (1382, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 247, in transform
    args.append(X[self._include])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 3819, in __getitem__
    data = self._take_with_is_copy(indexer, axis=1)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3902, in _take_with_is_copy
    result = self._take(indices=indices, axis=axis)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3886, in _take
    new_data = self._mgr.take(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 978, in take
    return self.reindex_indexer(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 743, in reindex_indexer
    new_blocks, new_refs = self._slice_take_blocks_ax0(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 912, in _slice_take_blocks_ax0
    nb = blk.take_nd(taker, axis=0, new_mgr_locs=mgr_locs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 880, in take_nd
    new_values = algos.take_nd(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 117, in take_nd
    return _take_nd_ndarray(arr, indexer, axis, fill_value, allow_fill)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 158, in _take_nd_ndarray
    out = np.empty(out_shape, dtype=dtype)
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (16384, 2823) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 262, in transform
    new_X = self._prepare_df(X, output)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 191, in _prepare_df
    out = to_df(out, index=X.index, columns=columns)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\utils\generic.py", line 109, in to_df
    data = data.rename(columns=lambda col: str(col))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 5573, in rename
    return super()._rename(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 1077, in _rename
    result = self if inplace else self.copy(deep=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6368, in copy
    data = self._mgr.copy(deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 649, in copy
    res = self.apply("copy", deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 549, in copy
    values = values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (16384, 5644) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 15:58:48,648:INFO:Calculating mean and std
2023-06-19 15:58:48,680:INFO:Creating metrics dataframe
2023-06-19 15:58:48,818:INFO:Uploading results into container
2023-06-19 15:58:48,822:INFO:Uploading model into container now
2023-06-19 15:58:48,827:INFO:_master_model_container: 6
2023-06-19 15:58:48,827:INFO:_display_container: 2
2023-06-19 15:58:48,832:INFO:DecisionTreeClassifier(ccp_alpha=0.0, class_weight=None, criterion='gini',
                       max_depth=None, max_features=None, max_leaf_nodes=None,
                       min_impurity_decrease=0.0, min_samples_leaf=1,
                       min_samples_split=2, min_weight_fraction_leaf=0.0,
                       random_state=123, splitter='best')
2023-06-19 15:58:48,832:INFO:create_model() successfully completed......................................
2023-06-19 15:58:49,784:WARNING:create_model() for DecisionTreeClassifier(ccp_alpha=0.0, class_weight=None, criterion='gini',
                       max_depth=None, max_features=None, max_leaf_nodes=None,
                       min_impurity_decrease=0.0, min_samples_leaf=1,
                       min_samples_split=2, min_weight_fraction_leaf=0.0,
                       random_state=123, splitter='best') raised an exception or returned all 0.0, trying without fit_kwargs:
2023-06-19 15:58:49,785:WARNING:Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 795, in compare_models
    np.sum(
AssertionError

2023-06-19 15:58:49,785:INFO:Initializing create_model()
2023-06-19 15:58:49,785:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000226BAA69ED0>, estimator=dt, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000226841BFAF0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 15:58:49,785:INFO:Checking exceptions
2023-06-19 15:58:49,785:INFO:Importing libraries
2023-06-19 15:58:49,786:INFO:Copying training dataset
2023-06-19 15:58:50,760:INFO:Defining folds
2023-06-19 15:58:50,760:INFO:Declaring metric variables
2023-06-19 15:58:50,767:INFO:Importing untrained model
2023-06-19 15:58:50,773:INFO:Decision Tree Classifier Imported successfully
2023-06-19 15:58:50,783:INFO:Starting cross validation
2023-06-19 15:58:51,130:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 15:58:57,798:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.13s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:58:57,944:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.31s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:58:57,944:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:58:58,448:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.09s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:58:58,646:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:58:59,085:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:58:59,249:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:58:59,294:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:58:59,973:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:59:00,012:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:59:00,141:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.46s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:59:02,081:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:59:08,934:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:59:13,574:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 15:59:57,906:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:00:00,166:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:00:00,596:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 5.13s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:00:04,207:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.08s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:00:07,362:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 1.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:00:07,529:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:00:07,533:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:00:07,536:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:00:55,252:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 0.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:00:57,827:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 0.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:00:57,959:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:00:57,962:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:00:57,965:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:00:58,098:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
8 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 94, in fit_resample
    X_, y_ = arrays_transformer.transform(output[0], y_)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 36, in transform
    X = self._transfrom_one(X, self.x_props)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 56, in _transfrom_one
    ret = ret.astype(props["dtypes"])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6226, in astype
    res_col = col.astype(dtype=cdt, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6240, in astype
    new_data = self._mgr.astype(dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 448, in astype
    return self.apply("astype", dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 526, in astype
    new_values = astype_array_safe(values, dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 299, in astype_array_safe
    new_values = astype_array(values, dtype, copy=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 222, in astype_array
    return values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 44.1 KiB for an array with shape (5648,) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 154, in _generate_samples
    diffs = nn_data[nn_num[rows, cols]] - X[rows]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (1021, 16384) and data type float64

--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 247, in transform
    args.append(X[self._include])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 3819, in __getitem__
    data = self._take_with_is_copy(indexer, axis=1)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3902, in _take_with_is_copy
    result = self._take(indices=indices, axis=axis)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3886, in _take
    new_data = self._mgr.take(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 978, in take
    return self.reindex_indexer(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 743, in reindex_indexer
    new_blocks, new_refs = self._slice_take_blocks_ax0(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 912, in _slice_take_blocks_ax0
    nb = blk.take_nd(taker, axis=0, new_mgr_locs=mgr_locs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 880, in take_nd
    new_values = algos.take_nd(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 117, in take_nd
    return _take_nd_ndarray(arr, indexer, axis, fill_value, allow_fill)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 158, in _take_nd_ndarray
    out = np.empty(out_shape, dtype=dtype)
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (16384, 2822) and data type float64

--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 161, in _generate_samples
    X_new = X[rows] + steps * diffs
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (1020, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 94, in fit_resample
    X_, y_ = arrays_transformer.transform(output[0], y_)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 36, in transform
    X = self._transfrom_one(X, self.x_props)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 56, in _transfrom_one
    ret = ret.astype(props["dtypes"])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6226, in astype
    res_col = col.astype(dtype=cdt, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6240, in astype
    new_data = self._mgr.astype(dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 448, in astype
    return self.apply("astype", dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 526, in astype
    new_values = astype_array_safe(values, dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 299, in astype_array_safe
    new_values = astype_array(values, dtype, copy=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 222, in astype_array
    return values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 44.1 KiB for an array with shape (5644,) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 16:00:58,123:INFO:Calculating mean and std
2023-06-19 16:00:58,182:INFO:Creating metrics dataframe
2023-06-19 16:00:58,491:INFO:Uploading results into container
2023-06-19 16:00:58,499:INFO:Uploading model into container now
2023-06-19 16:00:58,509:INFO:_master_model_container: 7
2023-06-19 16:00:58,509:INFO:_display_container: 2
2023-06-19 16:00:58,520:INFO:DecisionTreeClassifier(ccp_alpha=0.0, class_weight=None, criterion='gini',
                       max_depth=None, max_features=None, max_leaf_nodes=None,
                       min_impurity_decrease=0.0, min_samples_leaf=1,
                       min_samples_split=2, min_weight_fraction_leaf=0.0,
                       random_state=123, splitter='best')
2023-06-19 16:00:58,521:INFO:create_model() successfully completed......................................
2023-06-19 16:00:59,860:ERROR:create_model() for DecisionTreeClassifier(ccp_alpha=0.0, class_weight=None, criterion='gini',
                       max_depth=None, max_features=None, max_leaf_nodes=None,
                       min_impurity_decrease=0.0, min_samples_leaf=1,
                       min_samples_split=2, min_weight_fraction_leaf=0.0,
                       random_state=123, splitter='best') raised an exception or returned all 0.0:
2023-06-19 16:00:59,866:ERROR:Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 795, in compare_models
    np.sum(
AssertionError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 811, in compare_models
    np.sum(
AssertionError

2023-06-19 16:00:59,866:INFO:Initializing SVM - Linear Kernel
2023-06-19 16:00:59,866:INFO:Total runtime is 21.04126643339793 minutes
2023-06-19 16:00:59,899:INFO:SubProcess create_model() called ==================================
2023-06-19 16:00:59,899:INFO:Initializing create_model()
2023-06-19 16:00:59,899:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000226BAA69ED0>, estimator=svm, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x00000226841BFAF0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 16:00:59,899:INFO:Checking exceptions
2023-06-19 16:00:59,899:INFO:Importing libraries
2023-06-19 16:00:59,910:INFO:Copying training dataset
2023-06-19 16:01:01,017:INFO:Defining folds
2023-06-19 16:01:01,017:INFO:Declaring metric variables
2023-06-19 16:01:01,022:INFO:Importing untrained model
2023-06-19 16:01:01,027:INFO:SVM - Linear Kernel Imported successfully
2023-06-19 16:01:01,034:INFO:Starting cross validation
2023-06-19 16:01:01,421:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 16:01:04,566:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:01:06,448:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:01:06,472:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:01:08,981:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:01:10,209:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:01:10,728:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:01:10,816:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:01:12,912:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:01:13,195:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:01:13,801:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.41s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:01:15,521:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:01:18,631:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:07:15,122:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 16:07:15,122:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 16:07:15,122:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 16:07:15,122:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 16:07:20,171:WARNING:
'prophet' is a soft dependency and not included in the pycaret installation. Please run: `pip install prophet` to install.
2023-06-19 16:07:37,046:INFO:PyCaret ClassificationExperiment
2023-06-19 16:07:37,046:INFO:Logging name: clf-default-name
2023-06-19 16:07:37,048:INFO:ML Usecase: MLUsecase.CLASSIFICATION
2023-06-19 16:07:37,048:INFO:version 3.0.2
2023-06-19 16:07:37,048:INFO:Initializing setup()
2023-06-19 16:07:37,048:INFO:self.USI: 1d28
2023-06-19 16:07:37,048:INFO:self._variable_keys: {'html_param', 'pipeline', 'y_train', 'fold_groups_param', 'exp_id', 'fix_imbalance', '_available_plots', 'y_test', 'log_plots_param', 'logging_param', 'target_param', 'X_test', 'exp_name_log', 'memory', 'X_train', 'n_jobs_param', 'USI', 'gpu_param', 'y', '_ml_usecase', 'fold_generator', 'is_multiclass', 'gpu_n_jobs_param', 'seed', 'X', 'data', 'idx', 'fold_shuffle_param'}
2023-06-19 16:07:37,048:INFO:Checking environment
2023-06-19 16:07:37,048:INFO:python_version: 3.10.11
2023-06-19 16:07:37,048:INFO:python_build: ('main', 'Apr 20 2023 18:56:50')
2023-06-19 16:07:37,048:INFO:machine: AMD64
2023-06-19 16:07:37,048:INFO:platform: Windows-10-10.0.19041-SP0
2023-06-19 16:07:37,102:INFO:Memory: svmem(total=16901767168, available=1599528960, percent=90.5, used=15302238208, free=1599528960)
2023-06-19 16:07:37,102:INFO:Physical Core: 4
2023-06-19 16:07:37,102:INFO:Logical Core: 8
2023-06-19 16:07:37,102:INFO:Checking libraries
2023-06-19 16:07:37,102:INFO:System:
2023-06-19 16:07:37,102:INFO:    python: 3.10.11 | packaged by Anaconda, Inc. | (main, Apr 20 2023, 18:56:50) [MSC v.1916 64 bit (AMD64)]
2023-06-19 16:07:37,102:INFO:executable: c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\python.exe
2023-06-19 16:07:37,102:INFO:   machine: Windows-10-10.0.19041-SP0
2023-06-19 16:07:37,102:INFO:PyCaret required dependencies:
2023-06-19 16:07:37,102:INFO:                 pip: 23.0.1
2023-06-19 16:07:37,103:INFO:          setuptools: 67.8.0
2023-06-19 16:07:37,103:INFO:             pycaret: 3.0.2
2023-06-19 16:07:37,103:INFO:             IPython: 8.10.0
2023-06-19 16:07:37,103:INFO:          ipywidgets: 8.0.6
2023-06-19 16:07:37,103:INFO:                tqdm: 4.65.0
2023-06-19 16:07:37,103:INFO:               numpy: 1.23.5
2023-06-19 16:07:37,103:INFO:              pandas: 1.5.3
2023-06-19 16:07:37,103:INFO:              jinja2: 3.1.2
2023-06-19 16:07:37,103:INFO:               scipy: 1.10.1
2023-06-19 16:07:37,103:INFO:              joblib: 1.2.0
2023-06-19 16:07:37,103:INFO:             sklearn: 1.2.2
2023-06-19 16:07:37,104:INFO:                pyod: 1.0.9
2023-06-19 16:07:37,104:INFO:            imblearn: 0.10.1
2023-06-19 16:07:37,104:INFO:   category_encoders: 2.6.1
2023-06-19 16:07:37,104:INFO:            lightgbm: 3.3.5
2023-06-19 16:07:37,104:INFO:               numba: 0.57.0
2023-06-19 16:07:37,104:INFO:            requests: 2.31.0
2023-06-19 16:07:37,104:INFO:          matplotlib: 3.7.1
2023-06-19 16:07:37,104:INFO:          scikitplot: 0.3.7
2023-06-19 16:07:37,104:INFO:         yellowbrick: 1.5
2023-06-19 16:07:37,104:INFO:              plotly: 5.14.1
2023-06-19 16:07:37,104:INFO:             kaleido: 0.2.1
2023-06-19 16:07:37,105:INFO:         statsmodels: 0.14.0
2023-06-19 16:07:37,105:INFO:              sktime: 0.17.0
2023-06-19 16:07:37,105:INFO:               tbats: 1.1.3
2023-06-19 16:07:37,105:INFO:            pmdarima: 2.0.3
2023-06-19 16:07:37,105:INFO:              psutil: 5.9.4
2023-06-19 16:07:37,105:INFO:PyCaret optional dependencies:
2023-06-19 16:07:37,136:INFO:                shap: Not installed
2023-06-19 16:07:37,136:INFO:           interpret: Not installed
2023-06-19 16:07:37,136:INFO:                umap: Not installed
2023-06-19 16:07:37,136:INFO:    pandas_profiling: Not installed
2023-06-19 16:07:37,136:INFO:  explainerdashboard: Not installed
2023-06-19 16:07:37,136:INFO:             autoviz: Not installed
2023-06-19 16:07:37,136:INFO:           fairlearn: Not installed
2023-06-19 16:07:37,137:INFO:             xgboost: 1.7.6
2023-06-19 16:07:37,137:INFO:            catboost: Not installed
2023-06-19 16:07:37,137:INFO:              kmodes: Not installed
2023-06-19 16:07:37,137:INFO:             mlxtend: Not installed
2023-06-19 16:07:37,137:INFO:       statsforecast: Not installed
2023-06-19 16:07:37,137:INFO:        tune_sklearn: Not installed
2023-06-19 16:07:37,137:INFO:                 ray: Not installed
2023-06-19 16:07:37,137:INFO:            hyperopt: Not installed
2023-06-19 16:07:37,137:INFO:              optuna: Not installed
2023-06-19 16:07:37,137:INFO:               skopt: Not installed
2023-06-19 16:07:37,137:INFO:              mlflow: Not installed
2023-06-19 16:07:37,138:INFO:              gradio: Not installed
2023-06-19 16:07:37,138:INFO:             fastapi: Not installed
2023-06-19 16:07:37,138:INFO:             uvicorn: Not installed
2023-06-19 16:07:37,138:INFO:              m2cgen: Not installed
2023-06-19 16:07:37,138:INFO:           evidently: Not installed
2023-06-19 16:07:37,138:INFO:               fugue: Not installed
2023-06-19 16:07:37,138:INFO:           streamlit: Not installed
2023-06-19 16:07:37,138:INFO:             prophet: Not installed
2023-06-19 16:07:37,138:INFO:None
2023-06-19 16:07:37,139:INFO:Set up data.
2023-06-19 16:07:44,182:INFO:Set up train/test split.
2023-06-19 16:07:46,229:INFO:Set up index.
2023-06-19 16:07:46,676:INFO:Set up folding strategy.
2023-06-19 16:07:46,676:INFO:Assigning column types.
2023-06-19 16:07:47,079:INFO:Engine successfully changes for model 'lr' to 'sklearn'.
2023-06-19 16:07:47,128:INFO:Engine for model 'knn' has not been set explicitly, hence returning None.
2023-06-19 16:07:47,129:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2023-06-19 16:07:47,468:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 16:07:47,683:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 16:07:47,740:INFO:Engine for model 'knn' has not been set explicitly, hence returning None.
2023-06-19 16:07:47,741:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2023-06-19 16:07:47,781:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 16:07:47,785:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 16:07:47,786:INFO:Engine successfully changes for model 'knn' to 'sklearn'.
2023-06-19 16:07:47,844:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2023-06-19 16:07:47,893:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 16:07:47,896:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 16:07:47,967:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2023-06-19 16:07:48,012:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 16:07:48,018:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 16:07:48,018:INFO:Engine successfully changes for model 'rbfsvm' to 'sklearn'.
2023-06-19 16:07:48,232:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 16:07:48,243:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 16:07:48,542:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 16:07:48,547:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 16:07:48,610:INFO:Preparing preprocessing pipeline...
2023-06-19 16:07:48,777:INFO:Set up label encoding.
2023-06-19 16:07:48,777:INFO:Set up simple imputation.
2023-06-19 16:07:48,777:INFO:Set up imbalanced handling.
2023-06-19 16:07:48,777:INFO:Set up feature normalization.
2023-06-19 16:07:52,568:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:08:30,352:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:08:41,086:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.76s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:08:41,223:INFO:Finished creating preprocessing pipeline.
2023-06-19 16:08:41,518:INFO:Pipeline: Pipeline(memory=FastMemory(location=C:\Users\JOAO~1.COR\AppData\Local\Temp\joblib),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['X_0', 'X_1', 'X_2', 'X_3', 'X_4',
                                             'X_5', 'X_6', 'X_7', 'X_8', 'X_9',
                                             'X_10', 'X_11', 'X_12', 'X_13',
                                             'X_14',...
                                                              strategy='most_frequent',
                                                              verbose='deprecated'))),
                ('balance',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=FixImbalancer(estimator=SMOTE(k_neighbors=5,
                                                                              n_jobs=None,
                                                                              random_state=None,
                                                                              sampling_strategy='auto')))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True)))],
         verbose=False)
2023-06-19 16:08:41,518:INFO:Creating final display dataframe.
2023-06-19 16:08:58,768:INFO:Setup _display_container:                     Description  \
0                    Session id   
1                        Target   
2                   Target type   
3                Target mapping   
4           Original data shape   
5        Transformed data shape   
6   Transformed train set shape   
7    Transformed test set shape   
8              Numeric features   
9                    Preprocess   
10              Imputation type   
11           Numeric imputation   
12       Categorical imputation   
13                Fix imbalance   
14         Fix imbalance method   
15                    Normalize   
16             Normalize method   
17               Fold Generator   
18                  Fold Number   
19                     CPU Jobs   
20                      Use GPU   
21               Log Experiment   
22              Experiment Name   
23                          USI   

                                                Value  
0                                                 123  
1                                              target  
2                                          Multiclass  
3   Mild_Demented: 0, Moderate_Demented: 1, Non_De...  
4                                       (4480, 16385)  
5                                       (7616, 16385)  
6                                       (6272, 16385)  
7                                       (1344, 16385)  
8                                               16384  
9                                                True  
10                                             simple  
11                                               mean  
12                                               mode  
13                                               True  
14                                              SMOTE  
15                                               True  
16                                             zscore  
17                                    StratifiedKFold  
18                                                 10  
19                                                 -1  
20                                              False  
21                                              False  
22                                   clf-default-name  
23                                               1d28  
2023-06-19 16:08:59,030:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 16:08:59,034:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 16:08:59,209:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 16:08:59,217:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 16:08:59,218:INFO:setup() successfully completed in 83.07s...............
2023-06-19 16:08:59,244:INFO:Initializing compare_models()
2023-06-19 16:08:59,244:INFO:compare_models(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, include=None, fold=None, round=4, cross_validation=True, sort=F1, n_select=1, budget_time=None, turbo=True, errors=ignore, fit_kwargs=None, groups=None, experiment_custom_tags=None, probability_threshold=None, verbose=True, parallel=None, caller_params={'self': <pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, 'include': None, 'exclude': None, 'fold': None, 'round': 4, 'cross_validation': True, 'sort': 'F1', 'n_select': 1, 'budget_time': None, 'turbo': True, 'errors': 'ignore', 'fit_kwargs': None, 'groups': None, 'experiment_custom_tags': None, 'probability_threshold': None, 'engine': None, 'verbose': True, 'parallel': None, '__class__': <class 'pycaret.classification.oop.ClassificationExperiment'>}, exclude=None)
2023-06-19 16:08:59,244:INFO:Checking exceptions
2023-06-19 16:09:00,016:INFO:Preparing display monitor
2023-06-19 16:09:00,065:INFO:Initializing Logistic Regression
2023-06-19 16:09:00,065:INFO:Total runtime is 1.6681353251139323e-05 minutes
2023-06-19 16:09:00,071:INFO:SubProcess create_model() called ==================================
2023-06-19 16:09:00,074:INFO:Initializing create_model()
2023-06-19 16:09:00,074:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=lr, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 16:09:00,075:INFO:Checking exceptions
2023-06-19 16:09:00,075:INFO:Importing libraries
2023-06-19 16:09:00,075:INFO:Copying training dataset
2023-06-19 16:09:01,764:INFO:Defining folds
2023-06-19 16:09:01,765:INFO:Declaring metric variables
2023-06-19 16:09:01,769:INFO:Importing untrained model
2023-06-19 16:09:01,775:INFO:Logistic Regression Imported successfully
2023-06-19 16:09:01,789:INFO:Starting cross validation
2023-06-19 16:09:02,029:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 16:09:45,562:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.17s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:09:45,563:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.14s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:09:45,630:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.21s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:09:45,641:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.26s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:09:45,670:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.21s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:09:45,816:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.43s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:09:48,026:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:09:49,771:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.31s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:09:50,330:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:09:50,903:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.14s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:10:30,876:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.09s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:10:30,877:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.09s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:10:33,459:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.80s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:10:36,107:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:10:48,517:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.25s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:10:48,525:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.26s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:10:48,813:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.13s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:11:01,196:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.27s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:11:01,246:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.36s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:11:13,905:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 9.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:11:21,662:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.49s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:11:23,088:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 9.31s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:11:28,285:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 2.44s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:11:28,948:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:11:28,955:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:11:28,960:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:11:30,885:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:11:37,259:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 2.49s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:11:37,703:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:11:37,715:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:11:37,723:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:15:17,934:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.14s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:15:18,397:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.11s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:15:19,286:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:15:19,390:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:15:19,393:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:15:20,147:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:15:20,236:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:15:20,239:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:15:20,876:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
6 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 154, in _generate_samples
    diffs = nn_data[nn_num[rows, cols]] - X[rows]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (1021, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 262, in transform
    new_X = self._prepare_df(X, output)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 191, in _prepare_df
    out = to_df(out, index=X.index, columns=columns)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\utils\generic.py", line 109, in to_df
    data = data.rename(columns=lambda col: str(col))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 5573, in rename
    return super()._rename(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 1077, in _rename
    result = self if inplace else self.copy(deep=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6368, in copy
    data = self._mgr.copy(deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 649, in copy
    res = self.apply("copy", deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 549, in copy
    values = values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (16384, 5644) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 247, in transform
    args.append(X[self._include])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 3819, in __getitem__
    data = self._take_with_is_copy(indexer, axis=1)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3902, in _take_with_is_copy
    result = self._take(indices=indices, axis=axis)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3886, in _take
    new_data = self._mgr.take(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 978, in take
    return self.reindex_indexer(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 743, in reindex_indexer
    new_blocks, new_refs = self._slice_take_blocks_ax0(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 912, in _slice_take_blocks_ax0
    nb = blk.take_nd(taker, axis=0, new_mgr_locs=mgr_locs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 880, in take_nd
    new_values = algos.take_nd(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 117, in take_nd
    return _take_nd_ndarray(arr, indexer, axis, fill_value, allow_fill)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 158, in _take_nd_ndarray
    out = np.empty(out_shape, dtype=dtype)
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (16384, 2822) and data type float64

--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 154, in _generate_samples
    diffs = nn_data[nn_num[rows, cols]] - X[rows]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (1020, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 345, in _fit_resample
    X_resampled = [X.copy()]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (2823, 16384) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 16:15:20,897:INFO:Calculating mean and std
2023-06-19 16:15:20,943:INFO:Creating metrics dataframe
2023-06-19 16:15:21,115:INFO:Uploading results into container
2023-06-19 16:15:21,121:INFO:Uploading model into container now
2023-06-19 16:15:21,132:INFO:_master_model_container: 1
2023-06-19 16:15:21,132:INFO:_display_container: 2
2023-06-19 16:15:21,143:INFO:LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                   intercept_scaling=1, l1_ratio=None, max_iter=1000,
                   multi_class='auto', n_jobs=None, penalty='l2',
                   random_state=123, solver='lbfgs', tol=0.0001, verbose=0,
                   warm_start=False)
2023-06-19 16:15:21,143:INFO:create_model() successfully completed......................................
2023-06-19 16:15:23,437:INFO:SubProcess create_model() end ==================================
2023-06-19 16:15:23,437:INFO:Creating metrics dataframe
2023-06-19 16:15:23,459:INFO:Initializing K Neighbors Classifier
2023-06-19 16:15:23,460:INFO:Total runtime is 6.389928726355234 minutes
2023-06-19 16:15:23,465:INFO:SubProcess create_model() called ==================================
2023-06-19 16:15:23,465:INFO:Initializing create_model()
2023-06-19 16:15:23,465:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=knn, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 16:15:23,465:INFO:Checking exceptions
2023-06-19 16:15:23,466:INFO:Importing libraries
2023-06-19 16:15:23,466:INFO:Copying training dataset
2023-06-19 16:15:25,633:INFO:Defining folds
2023-06-19 16:15:25,633:INFO:Declaring metric variables
2023-06-19 16:15:25,661:INFO:Importing untrained model
2023-06-19 16:15:25,859:INFO:K Neighbors Classifier Imported successfully
2023-06-19 16:15:25,962:INFO:Starting cross validation
2023-06-19 16:15:26,659:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 16:15:35,135:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:15:35,762:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:16:14,430:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:16:17,421:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.30s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:16:34,544:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:16:34,547:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 3.18s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:16:35,440:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.89s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:16:35,914:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.37s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:16:37,318:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.76s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:16:39,818:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.01s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:16:40,789:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:16:47,810:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:16:51,567:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.13s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:16:51,655:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:16:51,703:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:16:51,713:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:16:53,157:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:16:53,219:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:16:53,284:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:16:53,664:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.33s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:16:56,371:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 4.76s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:16:59,635:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 3.13s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:17:24,178:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:17:24,666:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.43s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:17:31,208:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.47s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:17:31,207:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.77s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:17:35,338:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.20s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:17:36,730:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:17:41,138:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 15.11s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:17:41,521:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:17:42,586:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.20s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:17:44,048:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:17:45,064:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.89s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:17:45,417:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:17:45,428:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:17:45,436:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:17:47,358:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.29s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:17:47,880:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 11.13s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:17:48,266:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.16s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:17:49,330:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:17:51,423:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:17:54,339:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:18:09,566:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 2.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:18:11,972:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:18:12,030:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:18:12,136:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:18:12,339:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:18:12,576:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:18:14,639:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:18:15,229:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 3.12s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:18:15,301:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 3.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:18:15,824:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:18:16,045:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:18:18,301:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:18:19,570:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:18:19,572:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:18:19,579:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:18:19,581:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:18:19,587:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:18:19,589:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:18:21,314:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:18:22,044:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.43s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:18:23,425:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:18:24,332:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.82s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:18:26,214:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:18:27,836:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:18:31,032:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 4.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:18:35,075:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:18:35,088:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:18:35,100:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:18:35,500:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 2.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:18:37,135:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:18:37,144:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:18:37,148:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:18:38,851:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:18:38,860:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:18:38,867:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:18:39,313:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
4 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 365, in _fit_resample
    X_resampled = np.vstack(X_resampled)
  File "<__array_function__ internals>", line 180, in vstack
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\numpy\core\shape_base.py", line 282, in vstack
    return _nx.concatenate(arrs, 0)
  File "<__array_function__ internals>", line 180, in concatenate
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (5648, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 161, in _generate_samples
    X_new = X[rows] + steps * diffs
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (1021, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 161, in _generate_samples
    X_new = X[rows] + steps * diffs
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (1020, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 231, in _fit
    fitted_transformer = self._memory_fit(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 66, in _fit_one
    transformer.fit(*args, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 224, in fit
    args.append(X[self._include])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 3819, in __getitem__
    data = self._take_with_is_copy(indexer, axis=1)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3902, in _take_with_is_copy
    result = self._take(indices=indices, axis=axis)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3884, in _take
    self._consolidate_inplace()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 5980, in _consolidate_inplace
    self._protect_consolidate(f)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 5968, in _protect_consolidate
    result = f()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 5978, in f
    self._mgr = self._mgr.consolidate()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 686, in consolidate
    bm._consolidate_inplace()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 1871, in _consolidate_inplace
    self.blocks = _consolidate(self.blocks)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 2329, in _consolidate
    merged_blocks, _ = _merge_blocks(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 2388, in _merge_blocks
    new_values = new_values[argsort]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (16384, 5644) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 16:18:39,516:INFO:Calculating mean and std
2023-06-19 16:18:39,830:INFO:Creating metrics dataframe
2023-06-19 16:18:40,466:INFO:Uploading results into container
2023-06-19 16:18:40,474:INFO:Uploading model into container now
2023-06-19 16:18:40,488:INFO:_master_model_container: 2
2023-06-19 16:18:40,488:INFO:_display_container: 2
2023-06-19 16:18:40,503:INFO:KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',
                     metric_params=None, n_jobs=-1, n_neighbors=5, p=2,
                     weights='uniform')
2023-06-19 16:18:40,503:INFO:create_model() successfully completed......................................
2023-06-19 16:18:41,811:INFO:SubProcess create_model() end ==================================
2023-06-19 16:18:41,812:INFO:Creating metrics dataframe
2023-06-19 16:18:41,858:INFO:Initializing Naive Bayes
2023-06-19 16:18:41,858:INFO:Total runtime is 9.696565719445546 minutes
2023-06-19 16:18:41,867:INFO:SubProcess create_model() called ==================================
2023-06-19 16:18:41,869:INFO:Initializing create_model()
2023-06-19 16:18:41,869:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=nb, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 16:18:41,869:INFO:Checking exceptions
2023-06-19 16:18:41,870:INFO:Importing libraries
2023-06-19 16:18:41,871:INFO:Copying training dataset
2023-06-19 16:18:44,126:INFO:Defining folds
2023-06-19 16:18:44,126:INFO:Declaring metric variables
2023-06-19 16:18:44,137:INFO:Importing untrained model
2023-06-19 16:18:44,147:INFO:Naive Bayes Imported successfully
2023-06-19 16:18:44,167:INFO:Starting cross validation
2023-06-19 16:18:44,985:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 16:18:47,441:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:18:47,475:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:18:50,442:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.25s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:18:50,890:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.31s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:18:51,013:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.30s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:18:51,613:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.39s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:18:51,664:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.39s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:18:52,511:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.23s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:18:52,517:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.33s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:18:53,653:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.09s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:19:31,464:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 5.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:19:33,498:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.85s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:19:35,660:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.13s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:19:35,957:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.76s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:19:37,549:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:19:38,303:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.39s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:20:26,899:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.35s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:20:29,557:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 6.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:20:30,888:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.03s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:20:32,829:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.37s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:20:34,769:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.27s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:20:40,261:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:20:40,262:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.39s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:20:41,552:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.47s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:20:42,200:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:20:43,651:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.03s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:20:44,105:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:20:45,425:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.44s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:20:46,166:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:21:09,949:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 11.35s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:21:24,556:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 3.25s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:21:27,808:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 7.03s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:21:34,201:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 6.47s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:21:37,623:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:21:42,820:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 15.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:21:44,331:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 7.49s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:21:44,507:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:21:47,857:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.05s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:21:48,348:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.16s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:21:50,099:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:21:50,649:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:21:53,346:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.13s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:22:03,059:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 6.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:22:03,091:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 9.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:22:03,113:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 3.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:22:03,762:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.99s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:22:05,270:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.99s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:22:05,613:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.01s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:22:08,665:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 5.38s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:22:09,059:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 5.25s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:22:14,792:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.31s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:22:16,140:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.30s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:22:16,203:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:22:16,624:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.03s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:22:17,128:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.03s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:22:19,574:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:22:22,115:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:22:25,987:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.40s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:22:27,696:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:22:27,771:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:22:28,792:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.41s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:22:29,106:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:22:30,064:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 2.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:22:32,345:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 4.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:22:32,348:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.46s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:22:37,161:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:22:37,269:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:22:37,896:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.33s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:22:38,368:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 4.35s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:22:44,164:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:44,171:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:44,175:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:47,453:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:22:47,463:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:22:47,605:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:22:47,715:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:22:47,921:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:22:47,930:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:22:50,404:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:22:50,836:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:22:51,235:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:22:51,402:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:22:51,522:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 3.33s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:22:51,691:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 3.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:22:52,720:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:52,732:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:52,740:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:52,779:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:52,790:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:52,811:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:54,280:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:22:54,322:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 7.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:22:54,838:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:22:56,310:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:56,318:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:56,324:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:56,581:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:56,590:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:56,611:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:57,982:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 3.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:22:59,408:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:59,416:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:59,421:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:59,422:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:59,429:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:59,429:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:59,436:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:59,436:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:59,443:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:22:59,910:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
2 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 154, in _generate_samples
    diffs = nn_data[nn_num[rows, cols]] - X[rows]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (1022, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 154, in _generate_samples
    diffs = nn_data[nn_num[rows, cols]] - X[rows]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (1020, 16384) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 16:23:00,647:INFO:Calculating mean and std
2023-06-19 16:23:00,737:INFO:Creating metrics dataframe
2023-06-19 16:23:01,217:INFO:Uploading results into container
2023-06-19 16:23:01,225:INFO:Uploading model into container now
2023-06-19 16:23:01,241:INFO:_master_model_container: 3
2023-06-19 16:23:01,242:INFO:_display_container: 2
2023-06-19 16:23:01,256:INFO:GaussianNB(priors=None, var_smoothing=1e-09)
2023-06-19 16:23:01,257:INFO:create_model() successfully completed......................................
2023-06-19 16:23:03,649:WARNING:create_model() for GaussianNB(priors=None, var_smoothing=1e-09) raised an exception or returned all 0.0, trying without fit_kwargs:
2023-06-19 16:23:03,667:WARNING:Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 795, in compare_models
    np.sum(
AssertionError

2023-06-19 16:23:03,669:INFO:Initializing create_model()
2023-06-19 16:23:03,669:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=nb, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 16:23:03,669:INFO:Checking exceptions
2023-06-19 16:23:03,670:INFO:Importing libraries
2023-06-19 16:23:03,671:INFO:Copying training dataset
2023-06-19 16:23:05,801:INFO:Defining folds
2023-06-19 16:23:05,802:INFO:Declaring metric variables
2023-06-19 16:23:06,112:INFO:Importing untrained model
2023-06-19 16:23:06,117:INFO:Naive Bayes Imported successfully
2023-06-19 16:23:06,206:INFO:Starting cross validation
2023-06-19 16:23:07,952:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 16:23:11,072:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:23:11,090:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:23:11,386:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:23:14,572:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:23:15,692:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.32s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:23:15,709:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:23:16,800:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.05s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:23:16,862:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.14s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:23:17,498:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.99s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:23:17,640:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:23:17,734:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.37s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:23:18,667:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.26s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:23:19,160:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.31s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:23:19,888:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.44s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:23:21,492:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.33s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:23:22,241:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.10s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:24:18,947:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:24:23,114:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:24:39,205:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 6.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:24:41,902:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.77s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:24:44,055:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:24:49,842:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.85s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:25:21,018:ERROR:create_model() for GaussianNB(priors=None, var_smoothing=1e-09) raised an exception or returned all 0.0:
2023-06-19 16:25:21,035:ERROR:Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 795, in compare_models
    np.sum(
AssertionError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 808, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1519, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1114, in _create_model_with_cv
    scores = cross_validate(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 285, in cross_validate
    _warn_or_raise_about_fit_failures(results, error_score)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 367, in _warn_or_raise_about_fit_failures
    raise ValueError(all_fits_failed_message)
ValueError: 
All the 10 fits failed.
It is very likely that your model is misconfigured.
You can try to debug the error by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 154, in _generate_samples
    diffs = nn_data[nn_num[rows, cols]] - X[rows]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 128. MiB for an array with shape (1022, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 94, in fit_resample
    X_, y_ = arrays_transformer.transform(output[0], y_)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 36, in transform
    X = self._transfrom_one(X, self.x_props)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 56, in _transfrom_one
    ret = ret.astype(props["dtypes"])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6226, in astype
    res_col = col.astype(dtype=cdt, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6240, in astype
    new_data = self._mgr.astype(dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 448, in astype
    return self.apply("astype", dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 526, in astype
    new_values = astype_array_safe(values, dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 299, in astype_array_safe
    new_values = astype_array(values, dtype, copy=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 222, in astype_array
    return values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 44.1 KiB for an array with shape (5648,) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 94, in fit_resample
    X_, y_ = arrays_transformer.transform(output[0], y_)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 36, in transform
    X = self._transfrom_one(X, self.x_props)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 56, in _transfrom_one
    ret = ret.astype(props["dtypes"])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6226, in astype
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6240, in astype
    new_data = self._mgr.astype(dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 448, in astype
    return self.apply("astype", dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 526, in astype
    new_values = astype_array_safe(values, dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 299, in astype_array_safe
    new_values = astype_array(values, dtype, copy=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 222, in astype_array
    return values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 44.1 KiB for an array with shape (5644,) and data type float64

--------------------------------------------------------------------------------
5 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 94, in fit_resample
    X_, y_ = arrays_transformer.transform(output[0], y_)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 36, in transform
    X = self._transfrom_one(X, self.x_props)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 56, in _transfrom_one
    ret = ret.astype(props["dtypes"])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6226, in astype
    res_col = col.astype(dtype=cdt, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6240, in astype
    new_data = self._mgr.astype(dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 448, in astype
    return self.apply("astype", dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 526, in astype
    new_values = astype_array_safe(values, dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 299, in astype_array_safe
    new_values = astype_array(values, dtype, copy=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 222, in astype_array
    return values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 44.1 KiB for an array with shape (5644,) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 247, in transform
    args.append(X[self._include])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 3819, in __getitem__
    data = self._take_with_is_copy(indexer, axis=1)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3902, in _take_with_is_copy
    result = self._take(indices=indices, axis=axis)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3886, in _take
    new_data = self._mgr.take(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 978, in take
    return self.reindex_indexer(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 743, in reindex_indexer
    new_blocks, new_refs = self._slice_take_blocks_ax0(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 912, in _slice_take_blocks_ax0
    nb = blk.take_nd(taker, axis=0, new_mgr_locs=mgr_locs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 880, in take_nd
    new_values = algos.take_nd(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 117, in take_nd
    return _take_nd_ndarray(arr, indexer, axis, fill_value, allow_fill)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 158, in _take_nd_ndarray
    out = np.empty(out_shape, dtype=dtype)
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (16384, 2823) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 231, in _fit
    fitted_transformer = self._memory_fit(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 66, in _fit_one
    transformer.fit(*args, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 228, in fit
    self.transformer.fit(*args, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\impute\_base.py", line 390, in fit
    X = self._validate_input(X, in_fit=True)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\impute\_base.py", line 327, in _validate_input
    X = self._validate_data(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\base.py", line 565, in _validate_data
    X = check_array(X, input_name="X", **check_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\validation.py", line 879, in check_array
    array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_array_api.py", line 185, in _asarray_with_order
    array = numpy.asarray(array, order=order, dtype=dtype)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 2070, in __array__
    return np.asarray(self._values, dtype=dtype)
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (2823, 16384) and data type float64


2023-06-19 16:25:21,259:INFO:Initializing Decision Tree Classifier
2023-06-19 16:25:21,259:INFO:Total runtime is 16.353243593374888 minutes
2023-06-19 16:25:21,501:INFO:SubProcess create_model() called ==================================
2023-06-19 16:25:21,508:INFO:Initializing create_model()
2023-06-19 16:25:21,509:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=dt, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 16:25:21,509:INFO:Checking exceptions
2023-06-19 16:25:21,510:INFO:Importing libraries
2023-06-19 16:25:21,513:INFO:Copying training dataset
2023-06-19 16:25:23,388:INFO:Defining folds
2023-06-19 16:25:23,392:INFO:Declaring metric variables
2023-06-19 16:25:23,399:INFO:Importing untrained model
2023-06-19 16:25:23,414:INFO:Decision Tree Classifier Imported successfully
2023-06-19 16:25:23,428:INFO:Starting cross validation
2023-06-19 16:25:24,001:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 16:26:56,604:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:26:58,567:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:27:06,370:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 7.05s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:27:10,103:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:27:11,905:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 7.07s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:27:14,114:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:27:15,114:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:27:15,134:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.18s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:27:18,327:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:27:26,424:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.77s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:27:26,591:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:27:29,369:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:27:34,050:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:27:34,215:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:27:47,758:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 6.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:27:47,840:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.49s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:27:47,842:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.44s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:27:48,717:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:27:53,524:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:27:53,849:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.43s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:27:54,147:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.42s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:27:58,636:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.26s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:27:59,694:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:28:00,943:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.39s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:28:01,586:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.37s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:28:06,623:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:30:00,616:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:30:04,772:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.00s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:30:06,603:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:30:07,005:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.11s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:30:07,538:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:30:09,542:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:30:11,067:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:30:12,059:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.44s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:30:13,371:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.11s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:30:13,568:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.89s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:30:13,930:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:30:14,855:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.40s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:30:15,921:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:30:16,387:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:30:16,504:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.77s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:30:16,836:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.20s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:30:17,714:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:30:18,775:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:30:19,422:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:30:20,688:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:30:21,801:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:21,810:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:21,818:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:22,533:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.23s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:30:22,697:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.25s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:30:22,800:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:22,811:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:22,838:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:22,948:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:22,958:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:22,967:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:23,155:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:23,166:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:23,177:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:23,563:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.16s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:30:24,162:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:30:24,669:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:30:24,771:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:30:26,087:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:30:26,195:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:30:26,801:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:30:27,284:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:30:27,394:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:30:28,625:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.48s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:30:29,248:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:29,258:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:29,263:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:30,165:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:30:30,214:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:30,217:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:30,222:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:30,225:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:30,228:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:30,232:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:32,316:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:30:34,700:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.16s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:30:39,004:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:39,028:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:30:39,030:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:31:01,027:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:31:11,363:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:31:15,354:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:32:55,625:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:32:57,511:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:32:59,533:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:33:01,840:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:33:01,846:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:33:01,854:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:33:02,887:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
1 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 365, in _fit_resample
    X_resampled = np.vstack(X_resampled)
  File "<__array_function__ internals>", line 180, in vstack
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\numpy\core\shape_base.py", line 282, in vstack
    return _nx.concatenate(arrs, 0)
  File "<__array_function__ internals>", line 180, in concatenate
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (5644, 16384) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 16:33:02,913:INFO:Calculating mean and std
2023-06-19 16:33:02,992:INFO:Creating metrics dataframe
2023-06-19 16:33:03,844:INFO:Uploading results into container
2023-06-19 16:33:04,300:INFO:Uploading model into container now
2023-06-19 16:33:05,207:INFO:_master_model_container: 4
2023-06-19 16:33:05,207:INFO:_display_container: 2
2023-06-19 16:33:05,554:INFO:DecisionTreeClassifier(ccp_alpha=0.0, class_weight=None, criterion='gini',
                       max_depth=None, max_features=None, max_leaf_nodes=None,
                       min_impurity_decrease=0.0, min_samples_leaf=1,
                       min_samples_split=2, min_weight_fraction_leaf=0.0,
                       random_state=123, splitter='best')
2023-06-19 16:33:05,556:INFO:create_model() successfully completed......................................
2023-06-19 16:33:12,208:INFO:SubProcess create_model() end ==================================
2023-06-19 16:33:12,208:INFO:Creating metrics dataframe
2023-06-19 16:33:12,246:INFO:Initializing SVM - Linear Kernel
2023-06-19 16:33:12,247:INFO:Total runtime is 24.203048412005106 minutes
2023-06-19 16:33:12,257:INFO:SubProcess create_model() called ==================================
2023-06-19 16:33:12,259:INFO:Initializing create_model()
2023-06-19 16:33:12,259:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=svm, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 16:33:12,259:INFO:Checking exceptions
2023-06-19 16:33:12,259:INFO:Importing libraries
2023-06-19 16:33:12,259:INFO:Copying training dataset
2023-06-19 16:33:14,584:INFO:Defining folds
2023-06-19 16:33:14,584:INFO:Declaring metric variables
2023-06-19 16:33:14,589:INFO:Importing untrained model
2023-06-19 16:33:14,597:INFO:SVM - Linear Kernel Imported successfully
2023-06-19 16:33:14,614:INFO:Starting cross validation
2023-06-19 16:33:15,237:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 16:33:17,719:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:33:21,173:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.33s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:33:21,239:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.25s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:33:21,289:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.37s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:33:21,406:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.47s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:33:21,549:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.44s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:33:21,644:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.49s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:33:22,087:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.44s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:33:27,528:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.07s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:33:34,966:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.08s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:33:34,977:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 7.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:33:37,035:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.77s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:33:59,698:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.40s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:34:00,404:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:34:00,443:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.10s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:35:26,267:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:35:26,409:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:35:31,720:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.30s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:35:31,734:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.29s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:35:32,478:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.27s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:35:37,408:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.35s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:35:37,471:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.38s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:35:39,159:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:35:39,328:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:35:39,847:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.21s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:35:39,920:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:35:41,233:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.09s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:35:41,360:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.17s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:35:41,411:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:35:42,500:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.42s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:35:43,130:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:36:05,590:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:36:18,391:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.30s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:36:18,437:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.18s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:36:18,438:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:36:18,518:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:36:34,613:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 7.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:36:41,081:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 12.37s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:36:44,028:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:36:44,910:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 10.31s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:36:45,547:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.00s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:36:45,779:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:36:46,054:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.00s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:37:08,266:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:37:08,510:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:37:15,246:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.13s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:37:18,062:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 2.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:37:18,062:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:37:18,187:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.32s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:37:18,953:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 2.42s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:37:20,546:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:37:21,435:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.77s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:37:22,100:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:37:24,765:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 4.12s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:37:25,137:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:37:27,316:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:37:27,848:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:37:28,496:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 16:37:28,498:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 16:37:28,502:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:28,506:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:28,514:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:28,516:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:28,521:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:28,523:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:29,715:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.29s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:37:30,267:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.07s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:37:30,538:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.23s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:37:33,007:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.08s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:37:33,549:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:37:33,760:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.01s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:37:36,783:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:37:37,482:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:37:37,541:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:37:39,552:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 16:37:39,566:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:39,587:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 16:37:39,601:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:39,612:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:39,617:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:39,629:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:39,635:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:39,686:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 16:37:39,702:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:42,337:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:42,340:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:42,578:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:37:44,221:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.23s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:37:46,474:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:37:46,784:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 16:37:46,787:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:46,793:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:46,797:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:37:48,028:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:38:13,705:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:38:13,882:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 16:38:13,885:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:38:13,889:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:38:13,894:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:38:14,045:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
3 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 365, in _fit_resample
    X_resampled = np.vstack(X_resampled)
  File "<__array_function__ internals>", line 180, in vstack
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\numpy\core\shape_base.py", line 282, in vstack
    return _nx.concatenate(arrs, 0)
  File "<__array_function__ internals>", line 180, in concatenate
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (5644, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 232, in transform
    X = to_df(X, index=getattr(y, "index", None))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\utils\generic.py", line 109, in to_df
    data = data.rename(columns=lambda col: str(col))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 5573, in rename
    return super()._rename(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 1077, in _rename
    result = self if inplace else self.copy(deep=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6368, in copy
    data = self._mgr.copy(deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 649, in copy
    res = self.apply("copy", deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 549, in copy
    values = values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (16384, 5644) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 16:38:14,076:INFO:Calculating mean and std
2023-06-19 16:38:14,154:INFO:Creating metrics dataframe
2023-06-19 16:38:14,375:INFO:Uploading results into container
2023-06-19 16:38:14,381:INFO:Uploading model into container now
2023-06-19 16:38:14,394:INFO:_master_model_container: 5
2023-06-19 16:38:14,394:INFO:_display_container: 2
2023-06-19 16:38:14,407:INFO:SGDClassifier(alpha=0.0001, average=False, class_weight=None,
              early_stopping=False, epsilon=0.1, eta0=0.001, fit_intercept=True,
              l1_ratio=0.15, learning_rate='optimal', loss='hinge',
              max_iter=1000, n_iter_no_change=5, n_jobs=-1, penalty='l2',
              power_t=0.5, random_state=123, shuffle=True, tol=0.001,
              validation_fraction=0.1, verbose=0, warm_start=False)
2023-06-19 16:38:14,408:INFO:create_model() successfully completed......................................
2023-06-19 16:38:15,529:INFO:SubProcess create_model() end ==================================
2023-06-19 16:38:15,530:INFO:Creating metrics dataframe
2023-06-19 16:38:15,551:INFO:Initializing Ridge Classifier
2023-06-19 16:38:15,551:INFO:Total runtime is 29.25812148253123 minutes
2023-06-19 16:38:15,557:INFO:SubProcess create_model() called ==================================
2023-06-19 16:38:15,557:INFO:Initializing create_model()
2023-06-19 16:38:15,557:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=ridge, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 16:38:15,558:INFO:Checking exceptions
2023-06-19 16:38:15,558:INFO:Importing libraries
2023-06-19 16:38:15,558:INFO:Copying training dataset
2023-06-19 16:38:16,754:INFO:Defining folds
2023-06-19 16:38:16,754:INFO:Declaring metric variables
2023-06-19 16:38:16,760:INFO:Importing untrained model
2023-06-19 16:38:16,765:INFO:Ridge Classifier Imported successfully
2023-06-19 16:38:16,774:INFO:Starting cross validation
2023-06-19 16:38:17,259:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 16:38:20,389:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:38:20,435:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:38:20,460:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:38:20,555:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:38:22,614:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.22s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:38:22,900:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:38:23,566:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.22s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:38:23,814:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.36s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:38:24,327:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.36s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:38:24,405:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.36s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:38:24,596:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.32s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:38:24,725:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.49s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:38:27,510:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.08s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:38:28,542:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:38:39,374:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.00s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:38:39,374:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:38:39,952:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:38:41,468:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:40:00,401:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:40:12,351:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:40:14,168:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:40:15,895:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.99s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:40:17,028:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:40:17,115:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:40:20,199:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 6.13s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:40:22,761:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.80s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:40:23,939:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.47s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:40:25,208:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.43s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:40:38,949:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:40:50,307:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 7.41s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:40:50,450:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 3.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:40:50,643:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:40:22,015:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:40:51,122:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:40:51,695:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.41s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:40:51,783:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:40:53,058:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:40:53,604:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.16s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:41:11,560:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:41:15,847:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:41:19,980:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:41:22,605:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:41:24,993:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:41:28,869:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:41:42,551:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:41:46,019:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.01s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:41:55,966:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.05s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:41:57,234:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:41:59,579:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:42:00,273:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:42:00,603:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.20s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:42:02,910:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.31s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:42:03,320:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 16:42:03,327:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:42:03,334:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:42:03,341:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:42:03,564:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.27s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:42:04,013:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 16:42:04,018:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:42:04,030:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:42:04,040:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:42:35,286:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:42:36,895:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:42:38,968:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:42:39,237:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 16:42:39,242:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:42:39,249:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:42:39,259:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:42:39,427:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
7 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 247, in transform
    args.append(X[self._include])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 3819, in __getitem__
    data = self._take_with_is_copy(indexer, axis=1)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3902, in _take_with_is_copy
    result = self._take(indices=indices, axis=axis)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3886, in _take
    new_data = self._mgr.take(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 978, in take
    return self.reindex_indexer(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 743, in reindex_indexer
    new_blocks, new_refs = self._slice_take_blocks_ax0(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 912, in _slice_take_blocks_ax0
    nb = blk.take_nd(taker, axis=0, new_mgr_locs=mgr_locs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 880, in take_nd
    new_values = algos.take_nd(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 117, in take_nd
    return _take_nd_ndarray(arr, indexer, axis, fill_value, allow_fill)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 158, in _take_nd_ndarray
    out = np.empty(out_shape, dtype=dtype)
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (16384, 5648) and data type float64

--------------------------------------------------------------------------------
3 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 262, in transform
    new_X = self._prepare_df(X, output)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 191, in _prepare_df
    out = to_df(out, index=X.index, columns=columns)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\utils\generic.py", line 109, in to_df
    data = data.rename(columns=lambda col: str(col))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 5573, in rename
    return super()._rename(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 1077, in _rename
    result = self if inplace else self.copy(deep=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6368, in copy
    data = self._mgr.copy(deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 649, in copy
    res = self.apply("copy", deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 549, in copy
    values = values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (16384, 5644) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 365, in _fit_resample
    X_resampled = np.vstack(X_resampled)
  File "<__array_function__ internals>", line 180, in vstack
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\numpy\core\shape_base.py", line 282, in vstack
    return _nx.concatenate(arrs, 0)
  File "<__array_function__ internals>", line 180, in concatenate
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (5644, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 260, in fit
    fitted_estimator = self._memory_fit(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 66, in _fit_one
    transformer.fit(*args, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_ridge.py", line 1424, in fit
    super().fit(X, Y, sample_weight=sample_weight)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_ridge.py", line 900, in fit
    self.coef_, self.n_iter_ = _ridge_regression(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_ridge.py", line 645, in _ridge_regression
    X, y, sample_weight_sqrt = _rescale_data(X, y, sample_weight)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_base.py", line 322, in _rescale_data
    X = safe_sparse_dot(sw_matrix, X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\extmath.py", line 189, in safe_sparse_dot
    ret = a @ b
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\scipy\sparse\_base.py", line 630, in __matmul__
    return self._mul_dispatch(other)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\scipy\sparse\_base.py", line 532, in _mul_dispatch
    return self._mul_multivector(other)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\scipy\sparse\_base.py", line 600, in _mul_multivector
    return self.tocsr()._mul_multivector(other)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\scipy\sparse\_compressed.py", line 497, in _mul_multivector
    result = np.zeros((M, n_vecs),
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (5644, 16384) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 16:42:39,460:INFO:Calculating mean and std
2023-06-19 16:42:39,571:INFO:Creating metrics dataframe
2023-06-19 16:42:39,928:INFO:Uploading results into container
2023-06-19 16:42:39,935:INFO:Uploading model into container now
2023-06-19 16:42:39,950:INFO:_master_model_container: 6
2023-06-19 16:42:39,950:INFO:_display_container: 2
2023-06-19 16:42:39,969:INFO:RidgeClassifier(alpha=1.0, class_weight=None, copy_X=True, fit_intercept=True,
                max_iter=None, positive=False, random_state=123, solver='auto',
                tol=0.0001)
2023-06-19 16:42:39,969:INFO:create_model() successfully completed......................................
2023-06-19 16:42:42,202:WARNING:create_model() for RidgeClassifier(alpha=1.0, class_weight=None, copy_X=True, fit_intercept=True,
                max_iter=None, positive=False, random_state=123, solver='auto',
                tol=0.0001) raised an exception or returned all 0.0, trying without fit_kwargs:
2023-06-19 16:42:42,205:WARNING:Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 795, in compare_models
    np.sum(
AssertionError

2023-06-19 16:42:42,206:INFO:Initializing create_model()
2023-06-19 16:42:42,206:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=ridge, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 16:42:42,206:INFO:Checking exceptions
2023-06-19 16:42:42,206:INFO:Importing libraries
2023-06-19 16:42:42,207:INFO:Copying training dataset
2023-06-19 16:42:44,216:INFO:Defining folds
2023-06-19 16:42:44,217:INFO:Declaring metric variables
2023-06-19 16:42:44,226:INFO:Importing untrained model
2023-06-19 16:42:44,231:INFO:Ridge Classifier Imported successfully
2023-06-19 16:42:44,248:INFO:Starting cross validation
2023-06-19 16:42:44,844:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 16:42:47,598:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:42:47,728:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:42:47,834:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:42:47,889:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:42:47,937:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:42:50,746:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.27s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:42:51,138:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.00s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:42:51,633:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.03s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:42:53,104:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.20s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:42:53,495:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.47s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:42:53,629:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:42:53,631:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:42:54,393:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.41s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:42:55,378:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.16s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:42:55,640:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.34s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:42:59,820:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:43:01,060:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:44:29,002:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 9.27s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:44:29,008:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 7.77s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:44:33,266:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.35s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:44:33,605:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.10s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:44:34,880:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.01s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:44:35,130:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:44:35,255:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 7.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:44:36,118:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 7.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:44:36,844:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.33s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:44:37,521:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:44:38,975:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 11.32s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:44:49,874:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.05s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:44:52,751:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.22s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:44:54,126:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:44:54,785:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:44:57,936:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.21s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:44:59,203:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.05s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:45:02,340:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.25s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:45:19,734:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.34s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:45:45,126:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 6.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:45:47,029:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.00s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:45:47,586:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.48s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:45:49,524:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:45:52,612:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:45:53,261:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.14s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:45:54,898:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.10s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:45:55,070:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:45:55,630:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.89s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:45:57,056:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:45:58,029:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:45:58,381:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 16:45:58,387:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:45:58,396:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:45:58,401:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:45:58,529:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:45:58,957:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 16:45:58,961:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:45:58,971:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:45:58,977:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:45:59,735:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:46:00,130:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 16:46:00,137:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:46:00,145:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:46:00,151:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:46:00,858:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 14.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:46:16,487:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:46:18,316:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.05s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:46:20,282:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:46:20,492:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 16:46:20,495:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:46:20,500:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:46:20,507:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:46:29,337:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:46:29,510:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 16:46:29,511:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:46:29,515:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:46:29,518:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:46:29,680:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
5 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 365, in _fit_resample
    X_resampled = np.vstack(X_resampled)
  File "<__array_function__ internals>", line 180, in vstack
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\numpy\core\shape_base.py", line 282, in vstack
    return _nx.concatenate(arrs, 0)
  File "<__array_function__ internals>", line 180, in concatenate
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (5648, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 356, in _fit_resample
    X_new, y_new = self._make_samples(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 110, in _make_samples
    X_new = self._generate_samples(X, nn_data, nn_num, rows, cols, steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 154, in _generate_samples
    diffs = nn_data[nn_num[rows, cols]] - X[rows]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 52.4 MiB for an array with shape (419, 16384) and data type float64

--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 365, in _fit_resample
    X_resampled = np.vstack(X_resampled)
  File "<__array_function__ internals>", line 180, in vstack
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\numpy\core\shape_base.py", line 282, in vstack
    return _nx.concatenate(arrs, 0)
  File "<__array_function__ internals>", line 180, in concatenate
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (5644, 16384) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 16:46:29,712:INFO:Calculating mean and std
2023-06-19 16:46:29,804:INFO:Creating metrics dataframe
2023-06-19 16:46:30,088:INFO:Uploading results into container
2023-06-19 16:46:30,095:INFO:Uploading model into container now
2023-06-19 16:46:30,109:INFO:_master_model_container: 7
2023-06-19 16:46:30,109:INFO:_display_container: 2
2023-06-19 16:46:30,121:INFO:RidgeClassifier(alpha=1.0, class_weight=None, copy_X=True, fit_intercept=True,
                max_iter=None, positive=False, random_state=123, solver='auto',
                tol=0.0001)
2023-06-19 16:46:30,122:INFO:create_model() successfully completed......................................
2023-06-19 16:46:31,296:ERROR:create_model() for RidgeClassifier(alpha=1.0, class_weight=None, copy_X=True, fit_intercept=True,
                max_iter=None, positive=False, random_state=123, solver='auto',
                tol=0.0001) raised an exception or returned all 0.0:
2023-06-19 16:46:31,298:ERROR:Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 795, in compare_models
    np.sum(
AssertionError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 811, in compare_models
    np.sum(
AssertionError

2023-06-19 16:46:31,298:INFO:Initializing Random Forest Classifier
2023-06-19 16:46:31,298:INFO:Total runtime is 37.520565366745 minutes
2023-06-19 16:46:31,304:INFO:SubProcess create_model() called ==================================
2023-06-19 16:46:31,305:INFO:Initializing create_model()
2023-06-19 16:46:31,305:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=rf, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 16:46:31,305:INFO:Checking exceptions
2023-06-19 16:46:31,305:INFO:Importing libraries
2023-06-19 16:46:31,306:INFO:Copying training dataset
2023-06-19 16:46:32,788:INFO:Defining folds
2023-06-19 16:46:32,789:INFO:Declaring metric variables
2023-06-19 16:46:32,794:INFO:Importing untrained model
2023-06-19 16:46:32,800:INFO:Random Forest Classifier Imported successfully
2023-06-19 16:46:32,815:INFO:Starting cross validation
2023-06-19 16:46:33,429:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 16:46:38,461:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.11s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:46:38,955:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.21s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:46:38,990:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:46:39,661:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.37s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:46:39,718:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.37s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:46:39,890:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.42s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:46:40,045:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:46:40,288:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.48s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:46:43,941:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:46:44,503:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.82s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:46:44,643:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:46:44,686:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:46:53,599:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:47:54,972:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:47:56,210:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:47:57,722:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:48:01,163:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:48:09,690:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:48:09,963:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:48:10,310:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:48:21,496:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:48:22,513:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:48:22,655:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:48:24,345:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:48:42,669:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:48:43,352:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:48:44,406:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:48:46,388:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:48:46,786:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:48:48,864:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.27s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:48:53,991:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 2.00s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:49:01,269:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 7.26s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:49:14,835:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:49:15,429:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.11s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:49:16,676:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:49:17,430:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:49:20,132:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 2.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:49:20,477:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:49:20,480:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:49:20,486:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:49:20,492:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:49:21,228:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:49:23,482:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:49:24,144:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:49:25,454:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:49:25,459:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:49:25,464:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:49:25,983:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:49:25,987:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:49:25,992:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:49:26,123:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
7 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 94, in fit_resample
    X_, y_ = arrays_transformer.transform(output[0], y_)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 36, in transform
    X = self._transfrom_one(X, self.x_props)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 56, in _transfrom_one
    ret = ret.astype(props["dtypes"])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6226, in astype
    res_col = col.astype(dtype=cdt, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6240, in astype
    new_data = self._mgr.astype(dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 448, in astype
    return self.apply("astype", dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 526, in astype
    new_values = astype_array_safe(values, dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 299, in astype_array_safe
    new_values = astype_array(values, dtype, copy=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 222, in astype_array
    return values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 44.1 KiB for an array with shape (5648,) and data type float64

--------------------------------------------------------------------------------
5 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 94, in fit_resample
    X_, y_ = arrays_transformer.transform(output[0], y_)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 36, in transform
    X = self._transfrom_one(X, self.x_props)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 56, in _transfrom_one
    ret = ret.astype(props["dtypes"])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6226, in astype
    res_col = col.astype(dtype=cdt, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6240, in astype
    new_data = self._mgr.astype(dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 448, in astype
    return self.apply("astype", dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 526, in astype
    new_values = astype_array_safe(values, dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 299, in astype_array_safe
    new_values = astype_array(values, dtype, copy=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 222, in astype_array
    return values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 44.1 KiB for an array with shape (5644,) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 16:49:26,138:INFO:Calculating mean and std
2023-06-19 16:49:26,182:INFO:Creating metrics dataframe
2023-06-19 16:49:26,427:INFO:Uploading results into container
2023-06-19 16:49:26,431:INFO:Uploading model into container now
2023-06-19 16:49:26,441:INFO:_master_model_container: 8
2023-06-19 16:49:26,441:INFO:_display_container: 2
2023-06-19 16:49:26,451:INFO:RandomForestClassifier(bootstrap=True, ccp_alpha=0.0, class_weight=None,
                       criterion='gini', max_depth=None, max_features='sqrt',
                       max_leaf_nodes=None, max_samples=None,
                       min_impurity_decrease=0.0, min_samples_leaf=1,
                       min_samples_split=2, min_weight_fraction_leaf=0.0,
                       n_estimators=100, n_jobs=-1, oob_score=False,
                       random_state=123, verbose=0, warm_start=False)
2023-06-19 16:49:26,451:INFO:create_model() successfully completed......................................
2023-06-19 16:49:27,544:WARNING:create_model() for RandomForestClassifier(bootstrap=True, ccp_alpha=0.0, class_weight=None,
                       criterion='gini', max_depth=None, max_features='sqrt',
                       max_leaf_nodes=None, max_samples=None,
                       min_impurity_decrease=0.0, min_samples_leaf=1,
                       min_samples_split=2, min_weight_fraction_leaf=0.0,
                       n_estimators=100, n_jobs=-1, oob_score=False,
                       random_state=123, verbose=0, warm_start=False) raised an exception or returned all 0.0, trying without fit_kwargs:
2023-06-19 16:49:27,545:WARNING:Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 795, in compare_models
    np.sum(
AssertionError

2023-06-19 16:49:27,546:INFO:Initializing create_model()
2023-06-19 16:49:27,546:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=rf, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 16:49:27,546:INFO:Checking exceptions
2023-06-19 16:49:27,546:INFO:Importing libraries
2023-06-19 16:49:27,547:INFO:Copying training dataset
2023-06-19 16:49:28,755:INFO:Defining folds
2023-06-19 16:49:28,755:INFO:Declaring metric variables
2023-06-19 16:49:28,762:INFO:Importing untrained model
2023-06-19 16:49:28,767:INFO:Random Forest Classifier Imported successfully
2023-06-19 16:49:28,776:INFO:Starting cross validation
2023-06-19 16:49:30,362:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 16:49:32,703:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:49:32,773:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.77s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:49:33,162:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.82s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:49:35,505:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.05s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:49:35,791:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.23s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:49:35,870:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.12s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:49:36,286:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:49:36,606:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.42s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:49:36,817:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.40s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:49:37,554:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.37s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:49:38,500:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:49:40,715:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.38s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:49:51,184:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:49:52,679:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.43s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:49:52,724:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.47s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:49:52,756:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.35s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:49:52,819:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.36s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:49:52,830:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.46s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:49:53,113:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:51:10,092:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:51:10,098:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:51:13,741:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:51:13,914:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:51:25,616:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:51:39,663:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:51:50,951:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:51:54,491:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:51:54,897:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:51:54,995:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:52:11,505:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:52:12,601:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:52:18,387:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.89s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:52:18,535:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.10s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:52:19,227:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:52:28,541:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 2.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:52:30,932:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:52:35,637:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:52:43,477:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 7.82s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:52:51,644:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:52:52,515:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:52:53,843:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:52:56,018:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:52:56,440:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:52:57,253:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:52:58,370:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:52:58,771:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 2.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:52:59,180:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:52:59,228:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:52:59,236:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:52:59,242:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:53:01,016:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:53:01,789:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:53:06,437:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.85s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:53:07,008:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.82s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:53:08,255:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:53:08,794:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:53:10,241:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 1.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:53:10,458:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:53:10,463:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:53:10,468:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:53:10,587:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 1.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:53:10,803:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:53:10,806:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:53:10,810:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:53:10,971:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
7 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
2 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 94, in fit_resample
    X_, y_ = arrays_transformer.transform(output[0], y_)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 36, in transform
    X = self._transfrom_one(X, self.x_props)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 56, in _transfrom_one
    ret = ret.astype(props["dtypes"])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6226, in astype
    res_col = col.astype(dtype=cdt, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6240, in astype
    new_data = self._mgr.astype(dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 448, in astype
    return self.apply("astype", dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 526, in astype
    new_values = astype_array_safe(values, dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 299, in astype_array_safe
    new_values = astype_array(values, dtype, copy=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 222, in astype_array
    return values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 44.1 KiB for an array with shape (5648,) and data type float64

--------------------------------------------------------------------------------
5 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 94, in fit_resample
    X_, y_ = arrays_transformer.transform(output[0], y_)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 36, in transform
    X = self._transfrom_one(X, self.x_props)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\utils\_validation.py", line 56, in _transfrom_one
    ret = ret.astype(props["dtypes"])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6226, in astype
    res_col = col.astype(dtype=cdt, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6240, in astype
    new_data = self._mgr.astype(dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 448, in astype
    return self.apply("astype", dtype=dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 526, in astype
    new_values = astype_array_safe(values, dtype, copy=copy, errors=errors)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 299, in astype_array_safe
    new_values = astype_array(values, dtype, copy=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\dtypes\astype.py", line 222, in astype_array
    return values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 44.1 KiB for an array with shape (5644,) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 16:53:11,002:INFO:Calculating mean and std
2023-06-19 16:53:11,087:INFO:Creating metrics dataframe
2023-06-19 16:53:11,351:INFO:Uploading results into container
2023-06-19 16:53:11,357:INFO:Uploading model into container now
2023-06-19 16:53:11,371:INFO:_master_model_container: 9
2023-06-19 16:53:11,371:INFO:_display_container: 2
2023-06-19 16:53:11,387:INFO:RandomForestClassifier(bootstrap=True, ccp_alpha=0.0, class_weight=None,
                       criterion='gini', max_depth=None, max_features='sqrt',
                       max_leaf_nodes=None, max_samples=None,
                       min_impurity_decrease=0.0, min_samples_leaf=1,
                       min_samples_split=2, min_weight_fraction_leaf=0.0,
                       n_estimators=100, n_jobs=-1, oob_score=False,
                       random_state=123, verbose=0, warm_start=False)
2023-06-19 16:53:11,387:INFO:create_model() successfully completed......................................
2023-06-19 16:53:12,576:ERROR:create_model() for RandomForestClassifier(bootstrap=True, ccp_alpha=0.0, class_weight=None,
                       criterion='gini', max_depth=None, max_features='sqrt',
                       max_leaf_nodes=None, max_samples=None,
                       min_impurity_decrease=0.0, min_samples_leaf=1,
                       min_samples_split=2, min_weight_fraction_leaf=0.0,
                       n_estimators=100, n_jobs=-1, oob_score=False,
                       random_state=123, verbose=0, warm_start=False) raised an exception or returned all 0.0:
2023-06-19 16:53:12,577:ERROR:Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 795, in compare_models
    np.sum(
AssertionError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 811, in compare_models
    np.sum(
AssertionError

2023-06-19 16:53:12,578:INFO:Initializing Quadratic Discriminant Analysis
2023-06-19 16:53:12,578:INFO:Total runtime is 44.20856227080027 minutes
2023-06-19 16:53:12,586:INFO:SubProcess create_model() called ==================================
2023-06-19 16:53:12,586:INFO:Initializing create_model()
2023-06-19 16:53:12,587:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=qda, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 16:53:12,587:INFO:Checking exceptions
2023-06-19 16:53:12,587:INFO:Importing libraries
2023-06-19 16:53:12,587:INFO:Copying training dataset
2023-06-19 16:53:13,855:INFO:Defining folds
2023-06-19 16:53:13,855:INFO:Declaring metric variables
2023-06-19 16:53:13,860:INFO:Importing untrained model
2023-06-19 16:53:13,867:INFO:Quadratic Discriminant Analysis Imported successfully
2023-06-19 16:53:13,875:INFO:Starting cross validation
2023-06-19 16:53:14,340:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 16:53:18,962:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:53:19,018:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:53:19,167:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.09s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:53:19,793:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.37s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:53:19,863:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.27s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:53:19,910:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.12s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:53:19,973:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.23s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:53:20,066:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.30s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:53:23,262:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:53:36,567:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.49s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:53:36,568:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:54:01,627:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:54:02,597:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:54:09,471:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.21s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:54:09,471:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.21s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:54:09,783:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.30s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:54:10,134:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:54:10,254:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:54:10,517:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:54:11,918:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:54:12,348:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.01s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:54:17,405:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.85s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:55:13,024:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.82s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:55:38,372:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 18.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:55:40,032:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:55:56,821:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 5.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:55:57,154:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:56:01,215:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.76s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:56:01,383:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:56:01,767:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:56:02,553:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.37s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:56:08,788:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 16:56:10,114:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.36s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:56:26,283:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:56:26,488:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:56:39,503:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 4.16s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:56:39,826:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 16:56:39,871:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 5.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:56:40,199:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 6.12s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:56:43,678:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 27.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:56:44,292:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:56:46,624:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 5.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:56:48,970:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 16:56:53,568:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:56:54,060:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:56:54,505:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:56:56,692:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.18s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:57:00,790:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:57:02,121:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.47s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:57:13,132:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:57:14,043:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:57:16,842:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.23s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:57:17,047:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:57:19,744:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.47s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:57:20,100:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.46s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:57:32,159:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 16:57:32,161:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 16:57:35,393:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 16:58:36,592:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 60.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:58:42,561:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 29.18s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:58:42,969:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.77s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:58:43,229:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:58:48,868:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.46s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:58:51,833:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.27s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:58:53,737:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:58:57,662:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:59:07,835:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 9.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:59:18,428:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 26.37s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:59:20,868:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:59:21,206:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.82s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 16:59:38,493:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 21.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:59:39,413:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.85s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:59:39,415:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.23s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 16:59:39,812:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 22.80s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:59:40,040:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 22.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:59:43,592:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:59:43,985:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 2.09s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:59:47,136:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 21.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 16:59:47,444:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:59:47,938:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:59:51,940:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.42s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:59:52,598:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.40s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:59:52,674:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.47s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:59:53,071:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 5.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:59:54,038:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 6.07s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 16:59:55,564:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.46s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:59:56,296:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:59:56,447:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:59:57,507:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 16:59:59,516:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:59:59,528:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 16:59:59,535:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 16:59:59,538:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:00:00,238:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:00:00,252:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:00:00,257:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 17:00:00,261:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:00:01,700:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.48s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:00:03,275:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 7.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:00:04,048:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 7.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:00:05,291:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 8.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:00:08,297:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 6.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:00:11,377:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 17:00:11,519:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 17:00:18,018:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.32s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:00:19,816:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.43s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:00:21,318:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:00:22,466:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:00:23,067:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.20s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:00:23,316:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 2.31s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:00:25,338:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:00:26,795:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:00:27,386:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 5.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:00:28,897:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 6.09s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:00:31,526:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 5.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:00:31,890:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:00:31,902:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:00:31,908:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 17:00:31,911:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:00:32,384:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 5.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:00:33,499:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:00:33,509:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:00:33,515:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 17:00:33,518:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:00:35,933:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:00:35,945:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:00:35,950:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 17:00:35,953:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:00:36,942:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:00:36,955:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:00:36,960:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 17:00:36,963:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:01:35,556:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 17:01:35,581:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 17:01:43,288:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.29s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:01:43,491:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.39s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:01:52,448:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 2.29s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:01:52,835:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 2.33s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:01:55,023:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:01:55,029:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:01:55,033:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 17:01:55,036:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:01:55,353:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:01:55,361:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:01:55,365:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 17:01:55,367:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:01:55,641:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
2 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 260, in fit
    fitted_estimator = self._memory_fit(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 66, in _fit_one
    transformer.fit(*args, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py", line 921, in fit
    Xgc = Xg - meang
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 176. MiB for an array with shape (1412, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 260, in fit
    fitted_estimator = self._memory_fit(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 66, in _fit_one
    transformer.fit(*args, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py", line 913, in fit
    Xg = X[y == ind, :]
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 176. MiB for an array with shape (1411, 16384) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 17:01:55,674:INFO:Calculating mean and std
2023-06-19 17:01:55,752:INFO:Creating metrics dataframe
2023-06-19 17:01:56,047:INFO:Uploading results into container
2023-06-19 17:01:56,055:INFO:Uploading model into container now
2023-06-19 17:01:56,065:INFO:_master_model_container: 10
2023-06-19 17:01:56,066:INFO:_display_container: 2
2023-06-19 17:01:56,080:INFO:QuadraticDiscriminantAnalysis(priors=None, reg_param=0.0,
                              store_covariance=False, tol=0.0001)
2023-06-19 17:01:56,080:INFO:create_model() successfully completed......................................
2023-06-19 17:01:57,368:WARNING:create_model() for QuadraticDiscriminantAnalysis(priors=None, reg_param=0.0,
                              store_covariance=False, tol=0.0001) raised an exception or returned all 0.0, trying without fit_kwargs:
2023-06-19 17:01:57,372:WARNING:Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 795, in compare_models
    np.sum(
AssertionError

2023-06-19 17:01:57,372:INFO:Initializing create_model()
2023-06-19 17:01:57,372:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=qda, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 17:01:57,372:INFO:Checking exceptions
2023-06-19 17:01:57,372:INFO:Importing libraries
2023-06-19 17:01:57,373:INFO:Copying training dataset
2023-06-19 17:01:58,791:INFO:Defining folds
2023-06-19 17:01:58,791:INFO:Declaring metric variables
2023-06-19 17:01:58,806:INFO:Importing untrained model
2023-06-19 17:01:58,811:INFO:Quadratic Discriminant Analysis Imported successfully
2023-06-19 17:01:58,825:INFO:Starting cross validation
2023-06-19 17:02:00,097:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 17:02:05,959:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.03s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:02:05,968:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.99s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:02:06,107:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.10s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:02:06,278:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.22s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:02:06,279:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.25s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:02:06,424:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.34s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:02:06,895:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.12s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:02:07,139:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:02:10,728:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.34s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:02:15,183:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:02:16,938:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:02:18,619:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.26s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:02:29,190:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:02:29,263:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:02:29,518:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.29s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:02:29,746:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.48s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:02:29,895:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:02:29,966:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:02:30,089:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:02:31,550:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.11s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:02:31,805:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:02:31,806:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.76s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:02:31,867:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:02:31,996:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.43s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:02:31,997:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.22s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:02:32,141:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:02:33,530:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:02:33,975:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:02:34,068:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:02:34,468:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.17s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:02:34,490:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.20s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:04:00,729:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 9.76s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:04:06,648:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:04:08,711:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.20s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:04:10,929:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.03s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:04:15,651:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.25s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:04:19,945:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.00s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:04:25,223:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:04:27,213:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:04:28,685:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:04:29,152:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.16s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:04:29,403:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:04:29,823:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.36s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:04:29,913:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:04:30,618:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:04:31,775:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:04:31,802:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.11s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:05:13,308:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 3.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:05:13,612:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 3.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:05:13,620:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 4.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:05:14,778:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:05:14,813:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:05:15,830:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.43s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:05:21,052:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 6.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:05:46,015:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 15.01s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:05:46,435:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.47s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:05:46,599:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:05:47,862:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.48s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:05:48,430:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 17.43s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:05:48,901:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.03s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:05:49,351:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 6.42s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:05:50,542:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:06:22,748:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 17:06:32,241:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 17:06:32,240:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 17:06:32,241:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 17:06:33,107:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 17:06:40,330:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 17:06:40,332:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 17:06:40,338:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 17:06:46,292:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:07:45,733:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 17:09:21,512:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 33.29s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 17:09:24,346:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 37.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 17:09:30,654:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 11.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 17:09:32,937:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:09:32,959:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 13.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 17:09:34,622:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.08s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:09:34,665:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 15.43s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 17:09:35,419:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 2.35s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:09:36,919:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:09:37,474:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.17s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:09:37,986:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 21.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 17:09:39,439:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 14.25s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 17:09:39,725:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.26s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:09:43,905:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:09:44,558:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 7.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:09:45,005:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.43s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:09:46,495:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:09:46,698:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 6.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:09:47,903:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:09:48,941:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.42s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:09:49,987:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:09:50,247:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.30s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:09:53,930:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:09:54,460:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.49s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:09:54,679:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 6.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:09:57,868:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.29s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:09:58,073:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 4.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 17:09:59,150:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 9.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:09:59,905:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 9.49s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:10:00,464:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 6.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:10:04,860:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 6.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:10:08,079:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.37s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:10:10,896:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:10,907:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:10,911:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 17:10:10,914:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:11,148:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.09s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:10:12,544:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.10s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:10:13,137:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 11.39s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:10:13,425:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 11.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:10:13,847:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.07s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:10:16,407:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 5.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:10:19,664:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 4.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:10:19,716:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 4.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:10:20,330:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 6.26s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:10:20,350:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 4.32s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:10:20,369:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 4.36s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:10:22,651:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 8.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:10:23,237:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:10:25,789:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 6.09s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:10:26,228:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 6.46s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:10:26,570:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 6.21s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:10:26,843:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 6.43s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:10:28,113:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:28,124:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:28,131:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 17:10:28,135:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:29,296:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 6.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:10:31,511:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:31,520:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:31,526:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 17:10:31,530:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:32,205:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:32,219:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:32,223:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 17:10:32,228:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:32,620:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:32,633:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:32,640:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 17:10:32,643:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:32,820:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:32,830:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.29s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:10:32,860:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:32,864:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 17:10:32,870:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:34,346:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:34,356:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:34,361:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 17:10:34,363:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:34,897:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 17:10:39,104:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 4.18s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 17:10:42,551:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:42,558:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:42,562:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 17:10:42,566:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 17:10:42,767:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
2 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 254, in transform
    output = self.transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 541, in transform
    X, y = self.estimator.fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 203, in fit_resample
    return super().fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\base.py", line 88, in fit_resample
    output = self._fit_resample(X, y)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\imblearn\over_sampling\_smote\base.py", line 365, in _fit_resample
    X_resampled = np.vstack(X_resampled)
  File "<__array_function__ internals>", line 180, in vstack
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\numpy\core\shape_base.py", line 282, in vstack
    return _nx.concatenate(arrs, 0)
  File "<__array_function__ internals>", line 180, in concatenate
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (5648, 16384) and data type float64

--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 232, in transform
    X = to_df(X, index=getattr(y, "index", None))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\utils\generic.py", line 109, in to_df
    data = data.rename(columns=lambda col: str(col))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 5573, in rename
    return super()._rename(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 1077, in _rename
    result = self if inplace else self.copy(deep=copy)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 6368, in copy
    data = self._mgr.copy(deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 649, in copy
    res = self.apply("copy", deep=deep)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 352, in apply
    applied = getattr(b, f)(**kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 549, in copy
    values = values.copy()
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 353. MiB for an array with shape (16384, 2823) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 17:10:42,819:INFO:Calculating mean and std
2023-06-19 17:10:42,933:INFO:Creating metrics dataframe
2023-06-19 17:10:43,455:INFO:Uploading results into container
2023-06-19 17:10:43,465:INFO:Uploading model into container now
2023-06-19 17:10:43,483:INFO:_master_model_container: 11
2023-06-19 17:10:43,483:INFO:_display_container: 2
2023-06-19 17:10:43,502:INFO:QuadraticDiscriminantAnalysis(priors=None, reg_param=0.0,
                              store_covariance=False, tol=0.0001)
2023-06-19 17:10:43,502:INFO:create_model() successfully completed......................................
2023-06-19 17:10:45,012:ERROR:create_model() for QuadraticDiscriminantAnalysis(priors=None, reg_param=0.0,
                              store_covariance=False, tol=0.0001) raised an exception or returned all 0.0:
2023-06-19 17:10:45,014:ERROR:Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 795, in compare_models
    np.sum(
AssertionError

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 811, in compare_models
    np.sum(
AssertionError

2023-06-19 17:10:45,014:INFO:Initializing Ada Boost Classifier
2023-06-19 17:10:45,014:INFO:Total runtime is 61.749172282218936 minutes
2023-06-19 17:10:45,024:INFO:SubProcess create_model() called ==================================
2023-06-19 17:10:45,024:INFO:Initializing create_model()
2023-06-19 17:10:45,025:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=ada, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 17:10:45,025:INFO:Checking exceptions
2023-06-19 17:10:45,025:INFO:Importing libraries
2023-06-19 17:10:45,027:INFO:Copying training dataset
2023-06-19 17:10:47,083:INFO:Defining folds
2023-06-19 17:10:47,083:INFO:Declaring metric variables
2023-06-19 17:10:47,090:INFO:Importing untrained model
2023-06-19 17:10:47,099:INFO:Ada Boost Classifier Imported successfully
2023-06-19 17:10:47,114:INFO:Starting cross validation
2023-06-19 17:10:47,919:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 17:10:49,190:WARNING:create_model() for ada raised an exception or returned all 0.0, trying without fit_kwargs:
2023-06-19 17:10:49,203:WARNING:joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\queues.py", line 125, in _feed
    obj_ = dumps(obj, reducers=reducers)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 211, in dumps
    dump(obj, buf, reducers=reducers, protocol=protocol)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 204, in dump
    _LokyPickler(file, reducers=reducers, protocol=protocol).dump(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\cloudpickle\cloudpickle_fast.py", line 632, in dump
    return Pickler.dump(self, obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_memmapping_reducer.py", line 446, in __call__
    for dumped_filename in dump(a, filename):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 553, in dump
    NumpyPickler(f, protocol=protocol).dump(value)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\pickle.py", line 487, in dump
    self.save(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 352, in save
    wrapper.write_array(obj, self)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 134, in write_array
    pickler.file_handle.write(chunk.tobytes('C'))
OSError: [Errno 28] No space left on device
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 792, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1519, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1114, in _create_model_with_cv
    scores = cross_validate(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 266, in cross_validate
    results = parallel(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\parallel.py", line 63, in __call__
    return super().__call__(iterable_with_config)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 1098, in __call__
    self.retrieve()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 975, in retrieve
    self._output.extend(job.get(timeout=self.timeout))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_parallel_backends.py", line 567, in wrap_future_result
    return future.result(timeout=timeout)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 458, in result
    return self.__get_result()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 403, in __get_result
    raise self._exception
_pickle.PicklingError: Could not pickle the task to send it to the workers.

2023-06-19 17:10:49,204:INFO:Initializing create_model()
2023-06-19 17:10:49,205:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=ada, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 17:10:49,206:INFO:Checking exceptions
2023-06-19 17:10:49,206:INFO:Importing libraries
2023-06-19 17:10:49,206:INFO:Copying training dataset
2023-06-19 17:10:51,217:INFO:Defining folds
2023-06-19 17:10:51,218:INFO:Declaring metric variables
2023-06-19 17:10:51,227:INFO:Importing untrained model
2023-06-19 17:10:51,234:INFO:Ada Boost Classifier Imported successfully
2023-06-19 17:10:51,251:INFO:Starting cross validation
2023-06-19 17:10:51,569:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 17:10:52,368:ERROR:create_model() for ada raised an exception or returned all 0.0:
2023-06-19 17:10:52,369:ERROR:joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\queues.py", line 125, in _feed
    obj_ = dumps(obj, reducers=reducers)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 211, in dumps
    dump(obj, buf, reducers=reducers, protocol=protocol)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 204, in dump
    _LokyPickler(file, reducers=reducers, protocol=protocol).dump(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\cloudpickle\cloudpickle_fast.py", line 632, in dump
    return Pickler.dump(self, obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_memmapping_reducer.py", line 446, in __call__
    for dumped_filename in dump(a, filename):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 553, in dump
    NumpyPickler(f, protocol=protocol).dump(value)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\pickle.py", line 487, in dump
    self.save(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 352, in save
    wrapper.write_array(obj, self)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 134, in write_array
    pickler.file_handle.write(chunk.tobytes('C'))
OSError: [Errno 28] No space left on device
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 808, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1519, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1114, in _create_model_with_cv
    scores = cross_validate(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 266, in cross_validate
    results = parallel(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\parallel.py", line 63, in __call__
    return super().__call__(iterable_with_config)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 1098, in __call__
    self.retrieve()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 975, in retrieve
    self._output.extend(job.get(timeout=self.timeout))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_parallel_backends.py", line 567, in wrap_future_result
    return future.result(timeout=timeout)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 458, in result
    return self.__get_result()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 403, in __get_result
    raise self._exception
_pickle.PicklingError: Could not pickle the task to send it to the workers.

2023-06-19 17:10:52,370:INFO:Initializing Gradient Boosting Classifier
2023-06-19 17:10:52,370:INFO:Total runtime is 61.871760845184326 minutes
2023-06-19 17:10:52,381:INFO:SubProcess create_model() called ==================================
2023-06-19 17:10:52,383:INFO:Initializing create_model()
2023-06-19 17:10:52,383:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=gbc, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 17:10:52,383:INFO:Checking exceptions
2023-06-19 17:10:52,383:INFO:Importing libraries
2023-06-19 17:10:52,384:INFO:Copying training dataset
2023-06-19 17:10:54,422:INFO:Defining folds
2023-06-19 17:10:54,422:INFO:Declaring metric variables
2023-06-19 17:10:54,427:INFO:Importing untrained model
2023-06-19 17:10:54,435:INFO:Gradient Boosting Classifier Imported successfully
2023-06-19 17:10:54,450:INFO:Starting cross validation
2023-06-19 17:10:54,753:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 17:10:55,464:WARNING:create_model() for gbc raised an exception or returned all 0.0, trying without fit_kwargs:
2023-06-19 17:10:55,466:WARNING:joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\queues.py", line 125, in _feed
    obj_ = dumps(obj, reducers=reducers)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 211, in dumps
    dump(obj, buf, reducers=reducers, protocol=protocol)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 204, in dump
    _LokyPickler(file, reducers=reducers, protocol=protocol).dump(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\cloudpickle\cloudpickle_fast.py", line 632, in dump
    return Pickler.dump(self, obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_memmapping_reducer.py", line 446, in __call__
    for dumped_filename in dump(a, filename):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 553, in dump
    NumpyPickler(f, protocol=protocol).dump(value)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\pickle.py", line 487, in dump
    self.save(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 352, in save
    wrapper.write_array(obj, self)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 134, in write_array
    pickler.file_handle.write(chunk.tobytes('C'))
OSError: [Errno 28] No space left on device
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 792, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1519, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1114, in _create_model_with_cv
    scores = cross_validate(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 266, in cross_validate
    results = parallel(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\parallel.py", line 63, in __call__
    return super().__call__(iterable_with_config)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 1098, in __call__
    self.retrieve()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 975, in retrieve
    self._output.extend(job.get(timeout=self.timeout))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_parallel_backends.py", line 567, in wrap_future_result
    return future.result(timeout=timeout)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 458, in result
    return self.__get_result()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 403, in __get_result
    raise self._exception
_pickle.PicklingError: Could not pickle the task to send it to the workers.

2023-06-19 17:10:55,466:INFO:Initializing create_model()
2023-06-19 17:10:55,467:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=gbc, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 17:10:55,467:INFO:Checking exceptions
2023-06-19 17:10:55,467:INFO:Importing libraries
2023-06-19 17:10:55,468:INFO:Copying training dataset
2023-06-19 17:10:57,501:INFO:Defining folds
2023-06-19 17:10:57,502:INFO:Declaring metric variables
2023-06-19 17:10:57,511:INFO:Importing untrained model
2023-06-19 17:10:57,521:INFO:Gradient Boosting Classifier Imported successfully
2023-06-19 17:10:57,535:INFO:Starting cross validation
2023-06-19 17:10:57,836:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 17:10:59,326:ERROR:create_model() for gbc raised an exception or returned all 0.0:
2023-06-19 17:10:59,327:ERROR:joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\queues.py", line 125, in _feed
    obj_ = dumps(obj, reducers=reducers)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 211, in dumps
    dump(obj, buf, reducers=reducers, protocol=protocol)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 204, in dump
    _LokyPickler(file, reducers=reducers, protocol=protocol).dump(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\cloudpickle\cloudpickle_fast.py", line 632, in dump
    return Pickler.dump(self, obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_memmapping_reducer.py", line 446, in __call__
    for dumped_filename in dump(a, filename):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 553, in dump
    NumpyPickler(f, protocol=protocol).dump(value)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\pickle.py", line 487, in dump
    self.save(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 352, in save
    wrapper.write_array(obj, self)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 134, in write_array
    pickler.file_handle.write(chunk.tobytes('C'))
OSError: [Errno 28] No space left on device
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 808, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1519, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1114, in _create_model_with_cv
    scores = cross_validate(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 266, in cross_validate
    results = parallel(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\parallel.py", line 63, in __call__
    return super().__call__(iterable_with_config)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 1098, in __call__
    self.retrieve()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 975, in retrieve
    self._output.extend(job.get(timeout=self.timeout))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_parallel_backends.py", line 567, in wrap_future_result
    return future.result(timeout=timeout)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 451, in result
    return self.__get_result()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 403, in __get_result
    raise self._exception
_pickle.PicklingError: Could not pickle the task to send it to the workers.

2023-06-19 17:10:59,327:INFO:Initializing Linear Discriminant Analysis
2023-06-19 17:10:59,327:INFO:Total runtime is 61.987716523806256 minutes
2023-06-19 17:10:59,336:INFO:SubProcess create_model() called ==================================
2023-06-19 17:10:59,337:INFO:Initializing create_model()
2023-06-19 17:10:59,338:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=lda, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 17:10:59,338:INFO:Checking exceptions
2023-06-19 17:10:59,339:INFO:Importing libraries
2023-06-19 17:10:59,339:INFO:Copying training dataset
2023-06-19 17:11:01,241:INFO:Defining folds
2023-06-19 17:11:01,241:INFO:Declaring metric variables
2023-06-19 17:11:01,248:INFO:Importing untrained model
2023-06-19 17:11:01,253:INFO:Linear Discriminant Analysis Imported successfully
2023-06-19 17:11:01,266:INFO:Starting cross validation
2023-06-19 17:11:01,566:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 17:11:04,121:WARNING:create_model() for lda raised an exception or returned all 0.0, trying without fit_kwargs:
2023-06-19 17:11:04,124:WARNING:joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\queues.py", line 125, in _feed
    obj_ = dumps(obj, reducers=reducers)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 211, in dumps
    dump(obj, buf, reducers=reducers, protocol=protocol)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 204, in dump
    _LokyPickler(file, reducers=reducers, protocol=protocol).dump(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\cloudpickle\cloudpickle_fast.py", line 632, in dump
    return Pickler.dump(self, obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_memmapping_reducer.py", line 446, in __call__
    for dumped_filename in dump(a, filename):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 553, in dump
    NumpyPickler(f, protocol=protocol).dump(value)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\pickle.py", line 487, in dump
    self.save(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 352, in save
    wrapper.write_array(obj, self)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 134, in write_array
    pickler.file_handle.write(chunk.tobytes('C'))
OSError: [Errno 28] No space left on device
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 792, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1519, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1114, in _create_model_with_cv
    scores = cross_validate(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 266, in cross_validate
    results = parallel(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\parallel.py", line 63, in __call__
    return super().__call__(iterable_with_config)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 1098, in __call__
    self.retrieve()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 975, in retrieve
    self._output.extend(job.get(timeout=self.timeout))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_parallel_backends.py", line 567, in wrap_future_result
    return future.result(timeout=timeout)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 458, in result
    return self.__get_result()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 403, in __get_result
    raise self._exception
_pickle.PicklingError: Could not pickle the task to send it to the workers.

2023-06-19 17:11:04,125:INFO:Initializing create_model()
2023-06-19 17:11:04,125:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=lda, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 17:11:04,125:INFO:Checking exceptions
2023-06-19 17:11:04,126:INFO:Importing libraries
2023-06-19 17:11:04,126:INFO:Copying training dataset
2023-06-19 17:11:06,088:INFO:Defining folds
2023-06-19 17:11:06,089:INFO:Declaring metric variables
2023-06-19 17:11:06,096:INFO:Importing untrained model
2023-06-19 17:11:06,105:INFO:Linear Discriminant Analysis Imported successfully
2023-06-19 17:11:06,118:INFO:Starting cross validation
2023-06-19 17:11:06,418:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 17:11:07,100:ERROR:create_model() for lda raised an exception or returned all 0.0:
2023-06-19 17:11:07,101:ERROR:joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\queues.py", line 125, in _feed
    obj_ = dumps(obj, reducers=reducers)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 211, in dumps
    dump(obj, buf, reducers=reducers, protocol=protocol)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 204, in dump
    _LokyPickler(file, reducers=reducers, protocol=protocol).dump(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\cloudpickle\cloudpickle_fast.py", line 632, in dump
    return Pickler.dump(self, obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_memmapping_reducer.py", line 446, in __call__
    for dumped_filename in dump(a, filename):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 553, in dump
    NumpyPickler(f, protocol=protocol).dump(value)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\pickle.py", line 487, in dump
    self.save(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 352, in save
    wrapper.write_array(obj, self)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 134, in write_array
    pickler.file_handle.write(chunk.tobytes('C'))
OSError: [Errno 28] No space left on device
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 808, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1519, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1114, in _create_model_with_cv
    scores = cross_validate(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 266, in cross_validate
    results = parallel(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\parallel.py", line 63, in __call__
    return super().__call__(iterable_with_config)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 1098, in __call__
    self.retrieve()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 975, in retrieve
    self._output.extend(job.get(timeout=self.timeout))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_parallel_backends.py", line 567, in wrap_future_result
    return future.result(timeout=timeout)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 458, in result
    return self.__get_result()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 403, in __get_result
    raise self._exception
_pickle.PicklingError: Could not pickle the task to send it to the workers.

2023-06-19 17:11:07,101:INFO:Initializing Extra Trees Classifier
2023-06-19 17:11:07,102:INFO:Total runtime is 62.11729630231857 minutes
2023-06-19 17:11:07,114:INFO:SubProcess create_model() called ==================================
2023-06-19 17:11:07,115:INFO:Initializing create_model()
2023-06-19 17:11:07,115:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=et, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 17:11:07,115:INFO:Checking exceptions
2023-06-19 17:11:07,115:INFO:Importing libraries
2023-06-19 17:11:07,115:INFO:Copying training dataset
2023-06-19 17:11:09,110:INFO:Defining folds
2023-06-19 17:11:09,110:INFO:Declaring metric variables
2023-06-19 17:11:09,118:INFO:Importing untrained model
2023-06-19 17:11:09,124:INFO:Extra Trees Classifier Imported successfully
2023-06-19 17:11:09,141:INFO:Starting cross validation
2023-06-19 17:11:09,425:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 17:11:10,116:WARNING:create_model() for et raised an exception or returned all 0.0, trying without fit_kwargs:
2023-06-19 17:11:10,118:WARNING:joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\queues.py", line 125, in _feed
    obj_ = dumps(obj, reducers=reducers)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 211, in dumps
    dump(obj, buf, reducers=reducers, protocol=protocol)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 204, in dump
    _LokyPickler(file, reducers=reducers, protocol=protocol).dump(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\cloudpickle\cloudpickle_fast.py", line 632, in dump
    return Pickler.dump(self, obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_memmapping_reducer.py", line 446, in __call__
    for dumped_filename in dump(a, filename):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 553, in dump
    NumpyPickler(f, protocol=protocol).dump(value)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\pickle.py", line 487, in dump
    self.save(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 352, in save
    wrapper.write_array(obj, self)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 134, in write_array
    pickler.file_handle.write(chunk.tobytes('C'))
OSError: [Errno 28] No space left on device
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 792, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1519, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1114, in _create_model_with_cv
    scores = cross_validate(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 266, in cross_validate
    results = parallel(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\parallel.py", line 63, in __call__
    return super().__call__(iterable_with_config)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 1098, in __call__
    self.retrieve()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 975, in retrieve
    self._output.extend(job.get(timeout=self.timeout))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_parallel_backends.py", line 567, in wrap_future_result
    return future.result(timeout=timeout)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 458, in result
    return self.__get_result()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 403, in __get_result
    raise self._exception
_pickle.PicklingError: Could not pickle the task to send it to the workers.

2023-06-19 17:11:10,120:INFO:Initializing create_model()
2023-06-19 17:11:10,120:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=et, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 17:11:10,120:INFO:Checking exceptions
2023-06-19 17:11:10,121:INFO:Importing libraries
2023-06-19 17:11:10,121:INFO:Copying training dataset
2023-06-19 17:11:12,069:INFO:Defining folds
2023-06-19 17:11:12,069:INFO:Declaring metric variables
2023-06-19 17:11:12,077:INFO:Importing untrained model
2023-06-19 17:11:12,084:INFO:Extra Trees Classifier Imported successfully
2023-06-19 17:11:12,093:INFO:Starting cross validation
2023-06-19 17:11:12,396:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 17:11:13,878:ERROR:create_model() for et raised an exception or returned all 0.0:
2023-06-19 17:11:13,880:ERROR:joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\queues.py", line 125, in _feed
    obj_ = dumps(obj, reducers=reducers)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 211, in dumps
    dump(obj, buf, reducers=reducers, protocol=protocol)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 204, in dump
    _LokyPickler(file, reducers=reducers, protocol=protocol).dump(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\cloudpickle\cloudpickle_fast.py", line 632, in dump
    return Pickler.dump(self, obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_memmapping_reducer.py", line 446, in __call__
    for dumped_filename in dump(a, filename):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 553, in dump
    NumpyPickler(f, protocol=protocol).dump(value)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\pickle.py", line 487, in dump
    self.save(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 352, in save
    wrapper.write_array(obj, self)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 134, in write_array
    pickler.file_handle.write(chunk.tobytes('C'))
OSError: [Errno 28] No space left on device
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 808, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1519, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1114, in _create_model_with_cv
    scores = cross_validate(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 266, in cross_validate
    results = parallel(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\parallel.py", line 63, in __call__
    return super().__call__(iterable_with_config)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 1098, in __call__
    self.retrieve()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 975, in retrieve
    self._output.extend(job.get(timeout=self.timeout))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_parallel_backends.py", line 567, in wrap_future_result
    return future.result(timeout=timeout)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 451, in result
    return self.__get_result()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 403, in __get_result
    raise self._exception
_pickle.PicklingError: Could not pickle the task to send it to the workers.

2023-06-19 17:11:13,881:INFO:Initializing Extreme Gradient Boosting
2023-06-19 17:11:13,881:INFO:Total runtime is 62.230280156930284 minutes
2023-06-19 17:11:13,894:INFO:SubProcess create_model() called ==================================
2023-06-19 17:11:13,895:INFO:Initializing create_model()
2023-06-19 17:11:13,895:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=xgboost, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 17:11:13,895:INFO:Checking exceptions
2023-06-19 17:11:13,896:INFO:Importing libraries
2023-06-19 17:11:13,896:INFO:Copying training dataset
2023-06-19 17:11:15,807:INFO:Defining folds
2023-06-19 17:11:15,808:INFO:Declaring metric variables
2023-06-19 17:11:15,816:INFO:Importing untrained model
2023-06-19 17:11:15,822:INFO:Extreme Gradient Boosting Imported successfully
2023-06-19 17:11:15,834:INFO:Starting cross validation
2023-06-19 17:11:16,127:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 17:11:16,820:WARNING:create_model() for xgboost raised an exception or returned all 0.0, trying without fit_kwargs:
2023-06-19 17:11:16,822:WARNING:joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\queues.py", line 125, in _feed
    obj_ = dumps(obj, reducers=reducers)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 211, in dumps
    dump(obj, buf, reducers=reducers, protocol=protocol)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 204, in dump
    _LokyPickler(file, reducers=reducers, protocol=protocol).dump(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\cloudpickle\cloudpickle_fast.py", line 632, in dump
    return Pickler.dump(self, obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_memmapping_reducer.py", line 446, in __call__
    for dumped_filename in dump(a, filename):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 553, in dump
    NumpyPickler(f, protocol=protocol).dump(value)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\pickle.py", line 487, in dump
    self.save(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 352, in save
    wrapper.write_array(obj, self)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 134, in write_array
    pickler.file_handle.write(chunk.tobytes('C'))
OSError: [Errno 28] No space left on device
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 792, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1519, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1114, in _create_model_with_cv
    scores = cross_validate(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 266, in cross_validate
    results = parallel(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\parallel.py", line 63, in __call__
    return super().__call__(iterable_with_config)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 1098, in __call__
    self.retrieve()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 975, in retrieve
    self._output.extend(job.get(timeout=self.timeout))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_parallel_backends.py", line 567, in wrap_future_result
    return future.result(timeout=timeout)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 458, in result
    return self.__get_result()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 403, in __get_result
    raise self._exception
_pickle.PicklingError: Could not pickle the task to send it to the workers.

2023-06-19 17:11:16,823:INFO:Initializing create_model()
2023-06-19 17:11:16,824:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=xgboost, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 17:11:16,824:INFO:Checking exceptions
2023-06-19 17:11:16,825:INFO:Importing libraries
2023-06-19 17:11:16,825:INFO:Copying training dataset
2023-06-19 17:11:18,809:INFO:Defining folds
2023-06-19 17:11:18,809:INFO:Declaring metric variables
2023-06-19 17:11:18,819:INFO:Importing untrained model
2023-06-19 17:11:18,829:INFO:Extreme Gradient Boosting Imported successfully
2023-06-19 17:11:18,839:INFO:Starting cross validation
2023-06-19 17:11:19,103:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 17:11:19,765:ERROR:create_model() for xgboost raised an exception or returned all 0.0:
2023-06-19 17:11:19,766:ERROR:joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\queues.py", line 125, in _feed
    obj_ = dumps(obj, reducers=reducers)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 211, in dumps
    dump(obj, buf, reducers=reducers, protocol=protocol)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 204, in dump
    _LokyPickler(file, reducers=reducers, protocol=protocol).dump(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\cloudpickle\cloudpickle_fast.py", line 632, in dump
    return Pickler.dump(self, obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_memmapping_reducer.py", line 446, in __call__
    for dumped_filename in dump(a, filename):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 553, in dump
    NumpyPickler(f, protocol=protocol).dump(value)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\pickle.py", line 487, in dump
    self.save(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 352, in save
    wrapper.write_array(obj, self)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 134, in write_array
    pickler.file_handle.write(chunk.tobytes('C'))
OSError: [Errno 28] No space left on device
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 808, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1519, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1114, in _create_model_with_cv
    scores = cross_validate(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 266, in cross_validate
    results = parallel(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\parallel.py", line 63, in __call__
    return super().__call__(iterable_with_config)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 1098, in __call__
    self.retrieve()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 975, in retrieve
    self._output.extend(job.get(timeout=self.timeout))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_parallel_backends.py", line 567, in wrap_future_result
    return future.result(timeout=timeout)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 458, in result
    return self.__get_result()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 403, in __get_result
    raise self._exception
_pickle.PicklingError: Could not pickle the task to send it to the workers.

2023-06-19 17:11:19,767:INFO:Initializing Light Gradient Boosting Machine
2023-06-19 17:11:19,767:INFO:Total runtime is 62.32838652133941 minutes
2023-06-19 17:11:19,781:INFO:SubProcess create_model() called ==================================
2023-06-19 17:11:19,782:INFO:Initializing create_model()
2023-06-19 17:11:19,782:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=lightgbm, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 17:11:19,782:INFO:Checking exceptions
2023-06-19 17:11:19,782:INFO:Importing libraries
2023-06-19 17:11:19,783:INFO:Copying training dataset
2023-06-19 17:11:21,718:INFO:Defining folds
2023-06-19 17:11:21,718:INFO:Declaring metric variables
2023-06-19 17:11:21,724:INFO:Importing untrained model
2023-06-19 17:11:21,732:INFO:Light Gradient Boosting Machine Imported successfully
2023-06-19 17:11:21,749:INFO:Starting cross validation
2023-06-19 17:11:22,017:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 17:11:24,525:WARNING:create_model() for lightgbm raised an exception or returned all 0.0, trying without fit_kwargs:
2023-06-19 17:11:24,527:WARNING:joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\queues.py", line 125, in _feed
    obj_ = dumps(obj, reducers=reducers)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 211, in dumps
    dump(obj, buf, reducers=reducers, protocol=protocol)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 204, in dump
    _LokyPickler(file, reducers=reducers, protocol=protocol).dump(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\cloudpickle\cloudpickle_fast.py", line 632, in dump
    return Pickler.dump(self, obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_memmapping_reducer.py", line 446, in __call__
    for dumped_filename in dump(a, filename):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 553, in dump
    NumpyPickler(f, protocol=protocol).dump(value)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\pickle.py", line 487, in dump
    self.save(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 352, in save
    wrapper.write_array(obj, self)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 134, in write_array
    pickler.file_handle.write(chunk.tobytes('C'))
OSError: [Errno 28] No space left on device
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 792, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1519, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1114, in _create_model_with_cv
    scores = cross_validate(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 266, in cross_validate
    results = parallel(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\parallel.py", line 63, in __call__
    return super().__call__(iterable_with_config)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 1098, in __call__
    self.retrieve()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 975, in retrieve
    self._output.extend(job.get(timeout=self.timeout))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_parallel_backends.py", line 567, in wrap_future_result
    return future.result(timeout=timeout)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 458, in result
    return self.__get_result()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 403, in __get_result
    raise self._exception
_pickle.PicklingError: Could not pickle the task to send it to the workers.

2023-06-19 17:11:24,527:INFO:Initializing create_model()
2023-06-19 17:11:24,528:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=lightgbm, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 17:11:24,528:INFO:Checking exceptions
2023-06-19 17:11:24,528:INFO:Importing libraries
2023-06-19 17:11:24,528:INFO:Copying training dataset
2023-06-19 17:11:26,566:INFO:Defining folds
2023-06-19 17:11:26,566:INFO:Declaring metric variables
2023-06-19 17:11:26,573:INFO:Importing untrained model
2023-06-19 17:11:26,583:INFO:Light Gradient Boosting Machine Imported successfully
2023-06-19 17:11:26,601:INFO:Starting cross validation
2023-06-19 17:11:26,932:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 17:11:28,557:ERROR:create_model() for lightgbm raised an exception or returned all 0.0:
2023-06-19 17:11:28,558:ERROR:joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\queues.py", line 125, in _feed
    obj_ = dumps(obj, reducers=reducers)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 211, in dumps
    dump(obj, buf, reducers=reducers, protocol=protocol)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 204, in dump
    _LokyPickler(file, reducers=reducers, protocol=protocol).dump(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\cloudpickle\cloudpickle_fast.py", line 632, in dump
    return Pickler.dump(self, obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_memmapping_reducer.py", line 446, in __call__
    for dumped_filename in dump(a, filename):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 553, in dump
    NumpyPickler(f, protocol=protocol).dump(value)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\pickle.py", line 487, in dump
    self.save(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 352, in save
    wrapper.write_array(obj, self)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 134, in write_array
    pickler.file_handle.write(chunk.tobytes('C'))
OSError: [Errno 28] No space left on device
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 808, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1519, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1114, in _create_model_with_cv
    scores = cross_validate(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 266, in cross_validate
    results = parallel(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\parallel.py", line 63, in __call__
    return super().__call__(iterable_with_config)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 1098, in __call__
    self.retrieve()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 975, in retrieve
    self._output.extend(job.get(timeout=self.timeout))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_parallel_backends.py", line 567, in wrap_future_result
    return future.result(timeout=timeout)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 451, in result
    return self.__get_result()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 403, in __get_result
    raise self._exception
_pickle.PicklingError: Could not pickle the task to send it to the workers.

2023-06-19 17:11:28,558:INFO:Initializing Dummy Classifier
2023-06-19 17:11:28,559:INFO:Total runtime is 62.474907696247094 minutes
2023-06-19 17:11:28,570:INFO:SubProcess create_model() called ==================================
2023-06-19 17:11:28,570:INFO:Initializing create_model()
2023-06-19 17:11:28,570:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=dummy, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 17:11:28,571:INFO:Checking exceptions
2023-06-19 17:11:28,571:INFO:Importing libraries
2023-06-19 17:11:28,571:INFO:Copying training dataset
2023-06-19 17:11:30,607:INFO:Defining folds
2023-06-19 17:11:30,607:INFO:Declaring metric variables
2023-06-19 17:11:30,615:INFO:Importing untrained model
2023-06-19 17:11:30,623:INFO:Dummy Classifier Imported successfully
2023-06-19 17:11:30,638:INFO:Starting cross validation
2023-06-19 17:11:30,982:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 17:11:32,128:WARNING:create_model() for dummy raised an exception or returned all 0.0, trying without fit_kwargs:
2023-06-19 17:11:32,130:WARNING:joblib.externals.loky.process_executor._RemoteTraceback: 
"""
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\queues.py", line 125, in _feed
    obj_ = dumps(obj, reducers=reducers)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 211, in dumps
    dump(obj, buf, reducers=reducers, protocol=protocol)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\loky\backend\reduction.py", line 204, in dump
    _LokyPickler(file, reducers=reducers, protocol=protocol).dump(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\externals\cloudpickle\cloudpickle_fast.py", line 632, in dump
    return Pickler.dump(self, obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_memmapping_reducer.py", line 446, in __call__
    for dumped_filename in dump(a, filename):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 553, in dump
    NumpyPickler(f, protocol=protocol).dump(value)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\pickle.py", line 487, in dump
    self.save(obj)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 352, in save
    wrapper.write_array(obj, self)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\numpy_pickle.py", line 134, in write_array
    pickler.file_handle.write(chunk.tobytes('C'))
OSError: [Errno 28] No space left on device
"""

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 792, in compare_models
    model, model_fit_time = self._create_model(**create_model_args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1519, in _create_model
    model, model_fit_time, model_results, _ = self._create_model_with_cv(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pycaret_experiment\supervised_experiment.py", line 1114, in _create_model_with_cv
    scores = cross_validate(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 266, in cross_validate
    results = parallel(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\parallel.py", line 63, in __call__
    return super().__call__(iterable_with_config)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 1098, in __call__
    self.retrieve()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\parallel.py", line 975, in retrieve
    self._output.extend(job.get(timeout=self.timeout))
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\_parallel_backends.py", line 567, in wrap_future_result
    return future.result(timeout=timeout)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 458, in result
    return self.__get_result()
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\concurrent\futures\_base.py", line 403, in __get_result
    raise self._exception
_pickle.PicklingError: Could not pickle the task to send it to the workers.

2023-06-19 17:11:32,131:INFO:Initializing create_model()
2023-06-19 17:11:32,131:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x000001E173283730>, estimator=dummy, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001E173283490>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 17:11:32,131:INFO:Checking exceptions
2023-06-19 17:11:32,132:INFO:Importing libraries
2023-06-19 17:11:32,132:INFO:Copying training dataset
2023-06-19 17:11:34,096:INFO:Defining folds
2023-06-19 17:11:34,096:INFO:Declaring metric variables
2023-06-19 17:11:34,102:INFO:Importing untrained model
2023-06-19 17:11:34,107:INFO:Dummy Classifier Imported successfully
2023-06-19 17:11:34,117:INFO:Starting cross validation
2023-06-19 17:11:34,310:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 17:11:47,686:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.08s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:11:47,739:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.09s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:11:47,756:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:11:48,222:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.43s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:11:48,297:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.35s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:11:48,483:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:11:49,371:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:11:49,438:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:11:49,718:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.80s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:11:49,751:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.20s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:11:49,832:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:11:49,917:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.11s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 17:11:50,028:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:02:37,364:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:41:13,323:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 18:41:13,323:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 18:41:13,323:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 18:41:13,323:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 18:41:17,913:WARNING:
'prophet' is a soft dependency and not included in the pycaret installation. Please run: `pip install prophet` to install.
2023-06-19 18:41:34,231:INFO:PyCaret ClassificationExperiment
2023-06-19 18:41:34,231:INFO:Logging name: clf-default-name
2023-06-19 18:41:34,231:INFO:ML Usecase: MLUsecase.CLASSIFICATION
2023-06-19 18:41:34,231:INFO:version 3.0.2
2023-06-19 18:41:34,231:INFO:Initializing setup()
2023-06-19 18:41:34,231:INFO:self.USI: 92b5
2023-06-19 18:41:34,231:INFO:self._variable_keys: {'target_param', 'data', 'X_test', 'pipeline', 'fold_shuffle_param', 'log_plots_param', '_ml_usecase', 'USI', 'memory', 'X_train', 'fold_groups_param', 'fix_imbalance', 'y_test', 'n_jobs_param', 'y_train', '_available_plots', 'gpu_n_jobs_param', 'exp_id', 'idx', 'html_param', 'y', 'X', 'is_multiclass', 'fold_generator', 'gpu_param', 'seed', 'exp_name_log', 'logging_param'}
2023-06-19 18:41:34,232:INFO:Checking environment
2023-06-19 18:41:34,232:INFO:python_version: 3.10.11
2023-06-19 18:41:34,232:INFO:python_build: ('main', 'Apr 20 2023 18:56:50')
2023-06-19 18:41:34,232:INFO:machine: AMD64
2023-06-19 18:41:34,232:INFO:platform: Windows-10-10.0.19041-SP0
2023-06-19 18:41:34,235:INFO:Memory: svmem(total=16901767168, available=6001528832, percent=64.5, used=10900238336, free=6001528832)
2023-06-19 18:41:34,235:INFO:Physical Core: 4
2023-06-19 18:41:34,235:INFO:Logical Core: 8
2023-06-19 18:41:34,235:INFO:Checking libraries
2023-06-19 18:41:34,235:INFO:System:
2023-06-19 18:41:34,235:INFO:    python: 3.10.11 | packaged by Anaconda, Inc. | (main, Apr 20 2023, 18:56:50) [MSC v.1916 64 bit (AMD64)]
2023-06-19 18:41:34,235:INFO:executable: c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\python.exe
2023-06-19 18:41:34,235:INFO:   machine: Windows-10-10.0.19041-SP0
2023-06-19 18:41:34,235:INFO:PyCaret required dependencies:
2023-06-19 18:41:34,236:INFO:                 pip: 23.0.1
2023-06-19 18:41:34,236:INFO:          setuptools: 67.8.0
2023-06-19 18:41:34,236:INFO:             pycaret: 3.0.2
2023-06-19 18:41:34,236:INFO:             IPython: 8.10.0
2023-06-19 18:41:34,236:INFO:          ipywidgets: 8.0.6
2023-06-19 18:41:34,236:INFO:                tqdm: 4.65.0
2023-06-19 18:41:34,236:INFO:               numpy: 1.23.5
2023-06-19 18:41:34,236:INFO:              pandas: 1.5.3
2023-06-19 18:41:34,236:INFO:              jinja2: 3.1.2
2023-06-19 18:41:34,236:INFO:               scipy: 1.10.1
2023-06-19 18:41:34,236:INFO:              joblib: 1.2.0
2023-06-19 18:41:34,236:INFO:             sklearn: 1.2.2
2023-06-19 18:41:34,236:INFO:                pyod: 1.0.9
2023-06-19 18:41:34,236:INFO:            imblearn: 0.10.1
2023-06-19 18:41:34,236:INFO:   category_encoders: 2.6.1
2023-06-19 18:41:34,236:INFO:            lightgbm: 3.3.5
2023-06-19 18:41:34,236:INFO:               numba: 0.57.0
2023-06-19 18:41:34,236:INFO:            requests: 2.31.0
2023-06-19 18:41:34,236:INFO:          matplotlib: 3.7.1
2023-06-19 18:41:34,236:INFO:          scikitplot: 0.3.7
2023-06-19 18:41:34,236:INFO:         yellowbrick: 1.5
2023-06-19 18:41:34,236:INFO:              plotly: 5.14.1
2023-06-19 18:41:34,236:INFO:             kaleido: 0.2.1
2023-06-19 18:41:34,236:INFO:         statsmodels: 0.14.0
2023-06-19 18:41:34,237:INFO:              sktime: 0.17.0
2023-06-19 18:41:34,237:INFO:               tbats: 1.1.3
2023-06-19 18:41:34,237:INFO:            pmdarima: 2.0.3
2023-06-19 18:41:34,237:INFO:              psutil: 5.9.4
2023-06-19 18:41:34,237:INFO:PyCaret optional dependencies:
2023-06-19 18:41:34,256:INFO:                shap: Not installed
2023-06-19 18:41:34,256:INFO:           interpret: Not installed
2023-06-19 18:41:34,256:INFO:                umap: Not installed
2023-06-19 18:41:34,256:INFO:    pandas_profiling: Not installed
2023-06-19 18:41:34,256:INFO:  explainerdashboard: Not installed
2023-06-19 18:41:34,256:INFO:             autoviz: Not installed
2023-06-19 18:41:34,257:INFO:           fairlearn: Not installed
2023-06-19 18:41:34,257:INFO:             xgboost: 1.7.6
2023-06-19 18:41:34,257:INFO:            catboost: Not installed
2023-06-19 18:41:34,258:INFO:              kmodes: Not installed
2023-06-19 18:41:34,258:INFO:             mlxtend: Not installed
2023-06-19 18:41:34,258:INFO:       statsforecast: Not installed
2023-06-19 18:41:34,258:INFO:        tune_sklearn: Not installed
2023-06-19 18:41:34,258:INFO:                 ray: Not installed
2023-06-19 18:41:34,258:INFO:            hyperopt: Not installed
2023-06-19 18:41:34,258:INFO:              optuna: Not installed
2023-06-19 18:41:34,259:INFO:               skopt: Not installed
2023-06-19 18:41:34,259:INFO:              mlflow: Not installed
2023-06-19 18:41:34,259:INFO:              gradio: Not installed
2023-06-19 18:41:34,259:INFO:             fastapi: Not installed
2023-06-19 18:41:34,259:INFO:             uvicorn: Not installed
2023-06-19 18:41:34,259:INFO:              m2cgen: Not installed
2023-06-19 18:41:34,259:INFO:           evidently: Not installed
2023-06-19 18:41:34,259:INFO:               fugue: Not installed
2023-06-19 18:41:34,259:INFO:           streamlit: Not installed
2023-06-19 18:41:34,259:INFO:             prophet: Not installed
2023-06-19 18:41:34,259:INFO:None
2023-06-19 18:41:34,259:INFO:Set up data.
2023-06-19 18:41:37,924:INFO:Set up train/test split.
2023-06-19 18:41:38,557:INFO:Set up index.
2023-06-19 18:41:38,561:INFO:Set up folding strategy.
2023-06-19 18:41:38,562:INFO:Assigning column types.
2023-06-19 18:41:38,817:INFO:Engine successfully changes for model 'lr' to 'sklearn'.
2023-06-19 18:41:38,855:INFO:Engine for model 'knn' has not been set explicitly, hence returning None.
2023-06-19 18:41:38,856:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2023-06-19 18:41:38,908:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 18:41:38,970:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 18:41:39,006:INFO:Engine for model 'knn' has not been set explicitly, hence returning None.
2023-06-19 18:41:39,007:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2023-06-19 18:41:39,032:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 18:41:39,034:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 18:41:39,035:INFO:Engine successfully changes for model 'knn' to 'sklearn'.
2023-06-19 18:41:39,075:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2023-06-19 18:41:39,098:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 18:41:39,100:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 18:41:39,135:INFO:Engine for model 'rbfsvm' has not been set explicitly, hence returning None.
2023-06-19 18:41:39,157:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 18:41:39,160:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 18:41:39,160:INFO:Engine successfully changes for model 'rbfsvm' to 'sklearn'.
2023-06-19 18:41:39,219:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 18:41:39,221:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 18:41:39,282:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 18:41:39,284:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 18:41:39,286:INFO:Preparing preprocessing pipeline...
2023-06-19 18:41:39,332:INFO:Set up label encoding.
2023-06-19 18:41:39,332:INFO:Set up simple imputation.
2023-06-19 18:41:39,332:INFO:Set up imbalanced handling.
2023-06-19 18:41:39,332:INFO:Set up feature normalization.
2023-06-19 18:41:54,605:INFO:Finished creating preprocessing pipeline.
2023-06-19 18:41:54,701:INFO:Pipeline: Pipeline(memory=FastMemory(location=C:\Users\JOAO~1.COR\AppData\Local\Temp\joblib),
         steps=[('label_encoding',
                 TransformerWrapperWithInverse(exclude=None, include=None,
                                               transformer=LabelEncoder())),
                ('numerical_imputer',
                 TransformerWrapper(exclude=None,
                                    include=['X_0', 'X_1', 'X_2', 'X_3', 'X_4',
                                             'X_5', 'X_6', 'X_7', 'X_8', 'X_9',
                                             'X_10', 'X_11', 'X_12', 'X_13',
                                             'X_14',...
                                                              strategy='most_frequent',
                                                              verbose='deprecated'))),
                ('balance',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=FixImbalancer(estimator=SMOTE(k_neighbors=5,
                                                                              n_jobs=None,
                                                                              random_state=None,
                                                                              sampling_strategy='auto')))),
                ('normalize',
                 TransformerWrapper(exclude=None, include=None,
                                    transformer=StandardScaler(copy=True,
                                                               with_mean=True,
                                                               with_std=True)))],
         verbose=False)
2023-06-19 18:41:54,701:INFO:Creating final display dataframe.
2023-06-19 18:42:12,997:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 2.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 18:42:17,696:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:271: UserWarning: Persisting input arguments took 0.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_full_transform(

2023-06-19 18:42:22,799:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:271: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_full_transform(

2023-06-19 18:42:26,783:INFO:Setup _display_container:                     Description  \
0                    Session id   
1                        Target   
2                   Target type   
3                Target mapping   
4           Original data shape   
5        Transformed data shape   
6   Transformed train set shape   
7    Transformed test set shape   
8              Numeric features   
9                    Preprocess   
10              Imputation type   
11           Numeric imputation   
12       Categorical imputation   
13                Fix imbalance   
14         Fix imbalance method   
15                    Normalize   
16             Normalize method   
17               Fold Generator   
18                  Fold Number   
19                     CPU Jobs   
20                      Use GPU   
21               Log Experiment   
22              Experiment Name   
23                          USI   

                                                Value  
0                                                 123  
1                                              target  
2                                          Multiclass  
3   Mild_Demented: 0, Moderate_Demented: 1, Non_De...  
4                                       (4480, 16385)  
5                                       (7616, 16385)  
6                                       (6272, 16385)  
7                                       (1344, 16385)  
8                                               16384  
9                                                True  
10                                             simple  
11                                               mean  
12                                               mode  
13                                               True  
14                                              SMOTE  
15                                               True  
16                                             zscore  
17                                    StratifiedKFold  
18                                                 10  
19                                                 -1  
20                                              False  
21                                              False  
22                                   clf-default-name  
23                                               92b5  
2023-06-19 18:42:26,974:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 18:42:26,979:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 18:42:27,148:INFO:Soft dependency imported: xgboost: 1.7.6
2023-06-19 18:42:27,152:WARNING:
'catboost' is a soft dependency and not included in the pycaret installation. Please run: `pip install catboost` to install.
Alternately, you can install this by running `pip install pycaret[models]`
2023-06-19 18:42:27,153:INFO:setup() successfully completed in 53.1s...............
2023-06-19 18:42:27,166:INFO:Initializing compare_models()
2023-06-19 18:42:27,166:INFO:compare_models(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000114195CF5E0>, include=None, fold=None, round=4, cross_validation=True, sort=F1, n_select=1, budget_time=None, turbo=True, errors=ignore, fit_kwargs=None, groups=None, experiment_custom_tags=None, probability_threshold=None, verbose=True, parallel=None, caller_params={'self': <pycaret.classification.oop.ClassificationExperiment object at 0x00000114195CF5E0>, 'include': None, 'exclude': None, 'fold': None, 'round': 4, 'cross_validation': True, 'sort': 'F1', 'n_select': 1, 'budget_time': None, 'turbo': True, 'errors': 'ignore', 'fit_kwargs': None, 'groups': None, 'experiment_custom_tags': None, 'probability_threshold': None, 'engine': None, 'verbose': True, 'parallel': None, '__class__': <class 'pycaret.classification.oop.ClassificationExperiment'>}, exclude=None)
2023-06-19 18:42:27,167:INFO:Checking exceptions
2023-06-19 18:42:27,640:INFO:Preparing display monitor
2023-06-19 18:42:27,688:INFO:Initializing Logistic Regression
2023-06-19 18:42:27,688:INFO:Total runtime is 8.269151051839192e-06 minutes
2023-06-19 18:42:27,692:INFO:SubProcess create_model() called ==================================
2023-06-19 18:42:27,693:INFO:Initializing create_model()
2023-06-19 18:42:27,693:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000114195CF5E0>, estimator=lr, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001143F306AD0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 18:42:27,693:INFO:Checking exceptions
2023-06-19 18:42:27,693:INFO:Importing libraries
2023-06-19 18:42:27,693:INFO:Copying training dataset
2023-06-19 18:42:28,793:INFO:Defining folds
2023-06-19 18:42:28,794:INFO:Declaring metric variables
2023-06-19 18:42:28,801:INFO:Importing untrained model
2023-06-19 18:42:28,807:INFO:Logistic Regression Imported successfully
2023-06-19 18:42:28,817:INFO:Starting cross validation
2023-06-19 18:42:29,027:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 18:42:59,271:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:42:59,376:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:42:59,664:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.82s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:43:00,326:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.41s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:43:08,060:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.09s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:43:14,691:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.03s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:43:18,009:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:43:18,743:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.10s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:44:43,533:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:44:49,142:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 6.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:44:50,006:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:44:50,221:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:44:50,468:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.42s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:44:51,861:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:44:52,199:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:44:57,143:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:45:07,722:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.76s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:45:07,998:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:45:08,024:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:45:10,205:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:45:11,061:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:45:12,713:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.35s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:45:18,813:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.47s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:45:19,701:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:45:19,717:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.08s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:45:19,737:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.03s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:45:20,857:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:45:21,725:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:45:24,402:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.07s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:45:29,082:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.12s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:45:34,860:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:45:43,503:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.26s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:52:26,876:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 18:52:32,093:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.85s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 18:52:34,459:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 18:52:36,185:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 18:52:37,203:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 18:52:42,620:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.82s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 18:52:45,488:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 18:52:47,102:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 5.01s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 18:52:47,557:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:52:47,567:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:52:47,575:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:52:48,550:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:52:48,561:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:52:48,568:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:52:55,083:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:52:55,228:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:52:57,139:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 18:52:59,143:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:52:59,164:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:53:04,452:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 18:53:05,024:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 18:53:05,093:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:53:05,182:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:53:05,926:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 18:53:06,729:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:53:06,830:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.82s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:53:07,229:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 18:53:09,858:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.99s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 18:53:10,266:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 18:53:11,927:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 18:53:12,302:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.10s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 18:53:13,766:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:53:13,775:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:53:13,781:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:53:14,306:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 18:53:15,185:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 18:53:16,936:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 18:53:18,083:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:53:18,091:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:53:18,099:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:53:19,926:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:53:19,992:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:53:19,999:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:53:31,149:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 18:53:36,409:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 18:53:37,776:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 18:53:40,087:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.13s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 18:53:41,147:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:53:41,242:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:53:41,518:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 11.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 18:53:42,253:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:53:42,261:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:53:42,266:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:53:43,169:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 2.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 18:53:49,081:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 18:53:53,594:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:53:53,619:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:53:53,622:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:53:59,754:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 18:54:01,134:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 18:54:03,247:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 18:54:05,084:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:54:05,092:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:54:05,095:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:56:55,251:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 18:56:56,741:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.44s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 18:56:58,124:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:56:58,126:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:56:58,128:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:57:18,553:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 0.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 18:57:19,500:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:57:19,502:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:57:19,504:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:57:19,696:INFO:Calculating mean and std
2023-06-19 18:57:19,803:INFO:Creating metrics dataframe
2023-06-19 18:57:20,105:INFO:Uploading results into container
2023-06-19 18:57:20,110:INFO:Uploading model into container now
2023-06-19 18:57:20,126:INFO:_master_model_container: 1
2023-06-19 18:57:20,126:INFO:_display_container: 2
2023-06-19 18:57:20,140:INFO:LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                   intercept_scaling=1, l1_ratio=None, max_iter=1000,
                   multi_class='auto', n_jobs=None, penalty='l2',
                   random_state=123, solver='lbfgs', tol=0.0001, verbose=0,
                   warm_start=False)
2023-06-19 18:57:20,141:INFO:create_model() successfully completed......................................
2023-06-19 18:57:20,799:INFO:SubProcess create_model() end ==================================
2023-06-19 18:57:20,800:INFO:Creating metrics dataframe
2023-06-19 18:57:20,839:INFO:Initializing K Neighbors Classifier
2023-06-19 18:57:20,839:INFO:Total runtime is 14.885856548945108 minutes
2023-06-19 18:57:20,845:INFO:SubProcess create_model() called ==================================
2023-06-19 18:57:20,845:INFO:Initializing create_model()
2023-06-19 18:57:20,846:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000114195CF5E0>, estimator=knn, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001143F306AD0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 18:57:20,846:INFO:Checking exceptions
2023-06-19 18:57:20,846:INFO:Importing libraries
2023-06-19 18:57:20,846:INFO:Copying training dataset
2023-06-19 18:57:22,031:INFO:Defining folds
2023-06-19 18:57:22,032:INFO:Declaring metric variables
2023-06-19 18:57:22,036:INFO:Importing untrained model
2023-06-19 18:57:22,040:INFO:K Neighbors Classifier Imported successfully
2023-06-19 18:57:22,046:INFO:Starting cross validation
2023-06-19 18:57:22,352:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 18:57:25,300:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:57:25,397:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:57:25,430:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:57:25,446:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:57:25,495:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:57:25,496:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:57:25,521:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:57:25,539:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:57:27,959:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:57:42,483:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:57:43,064:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:57:44,204:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:57:44,204:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:57:44,558:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:57:45,793:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:57:46,582:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:57:56,025:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 7.27s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:57:57,654:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:58:03,292:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:58:04,388:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:58:05,511:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:58:12,475:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 7.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:58:30,389:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 11.14s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:58:45,549:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:58:58,501:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.44s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:59:04,128:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 6.99s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:59:04,981:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.13s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:59:05,011:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:59:05,310:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:59:05,455:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:59:05,710:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 9.14s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:59:08,548:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 18:59:10,934:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.12s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 18:59:15,841:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.13s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:59:21,054:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.14s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:59:21,565:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.40s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:59:21,807:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.89s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:59:23,000:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:59:23,052:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 18:59:23,156:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.20s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:59:23,617:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.11s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:59:24,867:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:59:24,874:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:59:24,880:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 18:59:30,185:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 18:59:30,413:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.29s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:59:30,465:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.33s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:59:30,475:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.30s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 18:59:36,894:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:00:11,154:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:00:14,859:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 4.21s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:00:24,082:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 10.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:00:24,176:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 10.38s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:00:24,727:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:00:24,818:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:00:25,231:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:00:29,910:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:00:35,595:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:00:39,258:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:00:39,258:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:00:39,279:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:00:41,317:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:00:43,650:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:00:46,173:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:00:46,814:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.42s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:00:47,600:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.34s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:00:48,338:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.45s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:00:49,931:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:00:55,969:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:00:56,933:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:00:56,944:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:00:56,971:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:00:57,153:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:00:57,373:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:00:57,414:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:00:58,221:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:00:58,227:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:00:58,228:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:00:58,231:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:00:58,234:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:00:58,239:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:00:58,846:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:00:58,854:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:00:58,856:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:00:59,165:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:01:00,090:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:01:00,304:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:01:01,914:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:01:05,819:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:01:05,886:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:01:05,890:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:01:08,949:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:01:08,982:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:01:08,988:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:01:09,015:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:01:09,044:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:01:09,047:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:01:26,663:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.18s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:01:32,083:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:01:32,088:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:01:32,093:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:01:57,765:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.26s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:02:03,296:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:02:03,300:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:02:03,302:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:02:03,503:INFO:Calculating mean and std
2023-06-19 19:02:03,643:INFO:Creating metrics dataframe
2023-06-19 19:02:04,386:INFO:Uploading results into container
2023-06-19 19:02:04,597:INFO:Uploading model into container now
2023-06-19 19:02:04,850:INFO:_master_model_container: 2
2023-06-19 19:02:04,850:INFO:_display_container: 2
2023-06-19 19:02:04,870:INFO:KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',
                     metric_params=None, n_jobs=-1, n_neighbors=5, p=2,
                     weights='uniform')
2023-06-19 19:02:04,870:INFO:create_model() successfully completed......................................
2023-06-19 19:02:05,953:INFO:SubProcess create_model() end ==================================
2023-06-19 19:02:05,953:INFO:Creating metrics dataframe
2023-06-19 19:02:05,989:INFO:Initializing Naive Bayes
2023-06-19 19:02:05,989:INFO:Total runtime is 19.638352755705515 minutes
2023-06-19 19:02:05,992:INFO:SubProcess create_model() called ==================================
2023-06-19 19:02:05,993:INFO:Initializing create_model()
2023-06-19 19:02:05,993:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000114195CF5E0>, estimator=nb, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001143F306AD0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 19:02:05,993:INFO:Checking exceptions
2023-06-19 19:02:05,993:INFO:Importing libraries
2023-06-19 19:02:05,994:INFO:Copying training dataset
2023-06-19 19:02:07,207:INFO:Defining folds
2023-06-19 19:02:07,207:INFO:Declaring metric variables
2023-06-19 19:02:07,212:INFO:Importing untrained model
2023-06-19 19:02:07,216:INFO:Naive Bayes Imported successfully
2023-06-19 19:02:07,223:INFO:Starting cross validation
2023-06-19 19:02:07,498:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 19:02:10,472:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:02:10,538:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:02:10,548:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:02:10,549:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:02:10,586:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:02:10,591:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:02:10,599:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:02:10,642:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:02:20,057:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:02:20,651:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:02:20,697:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:02:20,697:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:02:20,821:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:02:21,051:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:02:22,568:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:02:37,550:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:03:11,078:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.85s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:03:11,478:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.32s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:03:11,594:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:03:11,595:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.39s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:03:11,663:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:03:11,755:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.47s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:03:13,219:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.17s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:03:13,408:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:03:31,660:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.17s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:03:31,746:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.32s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:03:31,836:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.18s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:03:31,947:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:03:32,064:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:03:32,149:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:03:35,423:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.47s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:03:35,449:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.42s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:03:53,272:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.31s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:03:54,012:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:03:54,788:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.10s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:03:54,799:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:03:55,044:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:03:55,323:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 5.27s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:03:55,445:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:03:55,450:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:03:58,849:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:03:59,960:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:04:03,646:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:04,901:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:05,485:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:05,548:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:05,956:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.85s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:06,013:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.85s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:06,521:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:06,548:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:06,902:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:06,939:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:07,469:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:07,932:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:08,031:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.77s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:08,166:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:04:08,425:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:08,497:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:08,875:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:10,102:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:04:10,104:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:04:10,684:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:04:10,698:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:04:11,146:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:04:11,463:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:04:11,515:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:04:17,164:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 2.27s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:17,376:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 2.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:17,376:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 2.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:17,425:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 2.30s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:17,426:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:17,908:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 3.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:18,020:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 3.11s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:18,231:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:18,306:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 2.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:18,621:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:18,724:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:18,991:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:18,991:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:24,049:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 4.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:04:24,050:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 4.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:04:24,050:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 5.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:04:24,050:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 5.36s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:04:24,051:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 5.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:04:24,558:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:24,565:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:24,569:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:24,590:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:24,596:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:24,600:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:24,602:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:24,602:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:24,613:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:24,614:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:24,622:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:24,626:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:25,439:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 1.36s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:04:25,619:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 1.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:04:25,646:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 1.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:04:25,913:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:25,919:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:25,925:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:25,940:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 1.34s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:04:26,211:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:26,295:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:26,295:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:26,468:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:26,468:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:26,483:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:26,566:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:26,595:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:04:26,595:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:05:01,595:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 0.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:05:02,564:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:05:02,985:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:05:02,989:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:05:02,992:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:05:04,000:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:05:04,002:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:05:04,005:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:05:04,143:INFO:Calculating mean and std
2023-06-19 19:05:04,194:INFO:Creating metrics dataframe
2023-06-19 19:05:04,398:INFO:Uploading results into container
2023-06-19 19:05:04,401:INFO:Uploading model into container now
2023-06-19 19:05:04,411:INFO:_master_model_container: 3
2023-06-19 19:05:04,411:INFO:_display_container: 2
2023-06-19 19:05:04,417:INFO:GaussianNB(priors=None, var_smoothing=1e-09)
2023-06-19 19:05:04,417:INFO:create_model() successfully completed......................................
2023-06-19 19:05:05,510:INFO:SubProcess create_model() end ==================================
2023-06-19 19:05:05,510:INFO:Creating metrics dataframe
2023-06-19 19:05:05,532:INFO:Initializing Decision Tree Classifier
2023-06-19 19:05:05,532:INFO:Total runtime is 22.630744485060372 minutes
2023-06-19 19:05:05,536:INFO:SubProcess create_model() called ==================================
2023-06-19 19:05:05,536:INFO:Initializing create_model()
2023-06-19 19:05:05,536:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000114195CF5E0>, estimator=dt, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001143F306AD0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 19:05:05,537:INFO:Checking exceptions
2023-06-19 19:05:05,537:INFO:Importing libraries
2023-06-19 19:05:05,538:INFO:Copying training dataset
2023-06-19 19:05:06,363:INFO:Defining folds
2023-06-19 19:05:06,363:INFO:Declaring metric variables
2023-06-19 19:05:06,366:INFO:Importing untrained model
2023-06-19 19:05:06,371:INFO:Decision Tree Classifier Imported successfully
2023-06-19 19:05:06,378:INFO:Starting cross validation
2023-06-19 19:05:06,752:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 19:05:08,639:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:05:09,648:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:05:09,658:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:05:10,999:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:05:11,082:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:05:11,082:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:05:11,114:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:05:11,694:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:05:11,790:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:05:12,898:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:05:13,127:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:05:28,035:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:05:28,092:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:05:28,200:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:05:29,318:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:05:29,318:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:05:30,052:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:05:30,052:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:05:36,022:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.41s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:05:37,499:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:06:14,195:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.80s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:06:15,097:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:06:15,211:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:06:15,476:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:06:17,188:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:06:18,396:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:06:20,572:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:06:21,076:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:06:24,931:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.89s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:06:29,085:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:06:29,470:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.26s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:06:29,703:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.31s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:06:30,403:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.05s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:06:38,168:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 3.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:06:40,688:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 7.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:06:42,282:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:06:42,339:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.18s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:06:42,566:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:06:42,691:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:06:43,339:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.33s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:06:44,224:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:06:45,191:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:06:47,749:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.89s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:06:48,090:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:08:12,218:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:08:13,287:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:08:16,450:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.80s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:08:17,397:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:08:18,242:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:08:19,240:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:08:19,971:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:08:21,048:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:08:21,407:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.12s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:08:22,528:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.25s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:08:22,529:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.01s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:08:25,850:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:08:28,429:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:08:29,161:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:29,169:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:29,173:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:29,298:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:29,305:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:29,310:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:29,386:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:29,391:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:29,397:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:31,273:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:08:31,702:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:08:31,873:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:08:32,423:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.89s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:08:32,692:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:08:33,291:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:08:33,753:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:08:33,878:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:08:33,905:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:08:34,137:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:08:34,452:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:08:34,660:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:08:36,344:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.00s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:08:36,369:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:08:36,507:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:08:37,165:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:08:37,368:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:08:37,425:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:08:37,971:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:08:38,920:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:08:39,460:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:08:39,628:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:39,687:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:39,692:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:39,702:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:39,732:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:39,743:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:40,351:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:40,464:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:40,475:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:40,489:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:08:41,034:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:08:41,165:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:41,280:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:41,285:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:41,664:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:41,740:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:08:41,754:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:09:55,060:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 0.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:09:56,023:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:09:56,026:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:09:56,029:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:09:59,266:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 0.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:10:00,074:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:10:00,076:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:10:00,078:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:10:00,240:INFO:Calculating mean and std
2023-06-19 19:10:00,297:INFO:Creating metrics dataframe
2023-06-19 19:10:00,494:INFO:Uploading results into container
2023-06-19 19:10:00,499:INFO:Uploading model into container now
2023-06-19 19:10:00,513:INFO:_master_model_container: 4
2023-06-19 19:10:00,514:INFO:_display_container: 2
2023-06-19 19:10:00,520:INFO:DecisionTreeClassifier(ccp_alpha=0.0, class_weight=None, criterion='gini',
                       max_depth=None, max_features=None, max_leaf_nodes=None,
                       min_impurity_decrease=0.0, min_samples_leaf=1,
                       min_samples_split=2, min_weight_fraction_leaf=0.0,
                       random_state=123, splitter='best')
2023-06-19 19:10:00,520:INFO:create_model() successfully completed......................................
2023-06-19 19:10:01,240:INFO:SubProcess create_model() end ==================================
2023-06-19 19:10:01,240:INFO:Creating metrics dataframe
2023-06-19 19:10:01,261:INFO:Initializing SVM - Linear Kernel
2023-06-19 19:10:01,261:INFO:Total runtime is 27.55954893430074 minutes
2023-06-19 19:10:01,264:INFO:SubProcess create_model() called ==================================
2023-06-19 19:10:01,265:INFO:Initializing create_model()
2023-06-19 19:10:01,265:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000114195CF5E0>, estimator=svm, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001143F306AD0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 19:10:01,265:INFO:Checking exceptions
2023-06-19 19:10:01,265:INFO:Importing libraries
2023-06-19 19:10:01,267:INFO:Copying training dataset
2023-06-19 19:10:02,111:INFO:Defining folds
2023-06-19 19:10:02,111:INFO:Declaring metric variables
2023-06-19 19:10:02,114:INFO:Importing untrained model
2023-06-19 19:10:02,120:INFO:SVM - Linear Kernel Imported successfully
2023-06-19 19:10:02,126:INFO:Starting cross validation
2023-06-19 19:10:02,673:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 19:10:06,300:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.85s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:10:06,433:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:10:06,461:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:10:06,491:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:10:06,494:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:10:06,525:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:10:06,549:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:10:06,570:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.89s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:10:09,396:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:10:15,943:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:10:16,152:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:10:16,214:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:10:19,714:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:10:19,714:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:10:23,461:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.80s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:10:25,033:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.48s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:10:25,872:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:10:26,262:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:10:26,480:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:10:27,155:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:10:29,271:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:10:56,467:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:10:57,133:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.40s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:10:57,744:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.17s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:10:57,814:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:10:58,706:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:10:59,064:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:11:00,915:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:11:01,044:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:11:10,692:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.12s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:11:12,128:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:11:12,797:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.32s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:11:13,890:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.35s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:11:14,089:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.22s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:11:14,360:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.03s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:11:25,466:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:11:25,458:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:11:26,021:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.35s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:11:26,194:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.46s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:11:28,359:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.05s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:11:28,771:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.81s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:11:28,960:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:11:28,982:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:11:31,574:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:11:31,936:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:11:49,722:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 2.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:11:50,637:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 3.25s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:11:52,816:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:11:54,192:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:11:55,083:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:11:55,500:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:11:55,513:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:11:56,087:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.82s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:11:56,601:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:11:57,598:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:11:57,945:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:11:58,181:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:11:58,555:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:11:59,522:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:12:00,189:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:12:01,160:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:12:01,211:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:12:01,535:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:12:02,751:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 19:12:02,754:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 19:12:02,759:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:02,760:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:02,772:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:02,775:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:02,775:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:02,778:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:02,908:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.13s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:12:02,910:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.45s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:12:03,236:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 19:12:03,246:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:03,254:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:03,261:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:06,587:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:12:06,662:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:12:13,588:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 6.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:12:13,588:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 6.14s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:12:13,588:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 7.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:12:13,588:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 7.03s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:12:13,589:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 7.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:12:14,156:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:12:14,447:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 19:12:14,771:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:14,839:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:14,842:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:14,860:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 19:12:14,879:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 19:12:14,925:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:14,938:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:14,944:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:14,946:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:14,948:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:14,950:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:14,963:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.32s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:12:15,213:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 19:12:15,216:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:15,222:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:15,228:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:15,355:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:12:15,542:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 19:12:15,544:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:15,548:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:15,550:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:54,529:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 0.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:12:54,660:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 19:12:54,661:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:54,664:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:54,666:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:55,374:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.00s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:12:55,496:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_available_if.py", line 32, in __get__
    if not self.check(obj):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_stochastic_gradient.py", line 1235, in _check_proba
    raise AttributeError(
AttributeError: probability estimates are not available for loss='hinge'

  warnings.warn(

2023-06-19 19:12:55,497:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:55,500:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:55,502:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:12:55,651:INFO:Calculating mean and std
2023-06-19 19:12:55,699:INFO:Creating metrics dataframe
2023-06-19 19:12:56,046:INFO:Uploading results into container
2023-06-19 19:12:56,051:INFO:Uploading model into container now
2023-06-19 19:12:56,060:INFO:_master_model_container: 5
2023-06-19 19:12:56,061:INFO:_display_container: 2
2023-06-19 19:12:56,071:INFO:SGDClassifier(alpha=0.0001, average=False, class_weight=None,
              early_stopping=False, epsilon=0.1, eta0=0.001, fit_intercept=True,
              l1_ratio=0.15, learning_rate='optimal', loss='hinge',
              max_iter=1000, n_iter_no_change=5, n_jobs=-1, penalty='l2',
              power_t=0.5, random_state=123, shuffle=True, tol=0.001,
              validation_fraction=0.1, verbose=0, warm_start=False)
2023-06-19 19:12:56,071:INFO:create_model() successfully completed......................................
2023-06-19 19:12:59,314:INFO:SubProcess create_model() end ==================================
2023-06-19 19:12:59,314:INFO:Creating metrics dataframe
2023-06-19 19:12:59,333:INFO:Initializing Ridge Classifier
2023-06-19 19:12:59,333:INFO:Total runtime is 30.52742011944453 minutes
2023-06-19 19:12:59,337:INFO:SubProcess create_model() called ==================================
2023-06-19 19:12:59,337:INFO:Initializing create_model()
2023-06-19 19:12:59,337:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000114195CF5E0>, estimator=ridge, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001143F306AD0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 19:12:59,337:INFO:Checking exceptions
2023-06-19 19:12:59,337:INFO:Importing libraries
2023-06-19 19:12:59,338:INFO:Copying training dataset
2023-06-19 19:13:00,243:INFO:Defining folds
2023-06-19 19:13:00,243:INFO:Declaring metric variables
2023-06-19 19:13:00,247:INFO:Importing untrained model
2023-06-19 19:13:00,251:INFO:Ridge Classifier Imported successfully
2023-06-19 19:13:00,258:INFO:Starting cross validation
2023-06-19 19:13:00,764:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 19:13:03,869:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:13:03,911:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:13:04,282:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.89s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:13:04,318:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.99s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:13:04,342:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:13:04,355:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:13:04,371:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:13:04,395:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.01s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:13:07,169:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:13:07,222:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:13:12,843:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:13:14,493:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:13:14,626:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:13:14,638:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:13:15,415:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:13:16,163:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:13:16,831:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:13:16,960:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.80s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:13:17,295:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:13:17,402:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:13:17,515:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:13:19,487:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:13:19,502:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:13:49,972:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:13:50,874:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.05s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:13:50,985:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:13:51,304:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.46s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:13:51,342:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.01s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:13:51,343:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:13:51,527:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:13:52,321:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.76s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:14:06,356:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.48s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:14:08,346:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:14:09,472:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:14:10,333:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.20s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:14:10,837:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.16s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:14:11,187:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:14:11,352:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.38s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:14:11,707:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.42s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:14:30,797:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 7.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:14:32,146:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.35s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:14:32,530:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:14:32,541:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:14:32,577:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:14:32,872:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 9.77s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:14:33,297:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:14:33,507:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 9.80s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:15:27,199:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 2.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:15:27,237:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 2.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:15:30,029:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 2.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:15:30,391:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 2.12s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:15:32,886:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 2.08s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:15:37,281:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:15:37,246:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:15:37,462:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:15:37,704:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:15:37,899:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:15:38,373:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:15:39,089:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:15:39,255:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:15:39,286:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:15:39,685:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.80s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:15:39,915:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:15:40,010:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 3.30s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:15:40,103:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 3.39s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:15:41,823:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:15:41,943:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.21s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:15:42,232:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:15:42,266:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:15:42,273:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 19:15:42,289:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:42,300:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:42,307:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:42,623:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 19:15:42,628:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:42,639:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:42,645:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:42,677:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 19:15:42,683:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:42,696:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:42,703:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:42,784:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:15:42,887:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.89s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:15:43,161:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 19:15:43,166:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:43,176:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:43,183:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:43,334:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 19:15:43,340:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:43,350:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:43,357:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:45,055:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:15:45,416:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:15:45,524:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:15:47,232:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.87s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:15:47,362:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:15:50,250:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:15:51,273:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:15:52,281:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 4.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:15:54,482:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 4.44s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:15:55,118:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.12s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:15:55,204:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 19:15:55,258:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:55,343:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:55,348:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:55,760:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 19:15:55,795:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:55,835:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:55,840:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:15:56,306:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:16:33,479:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 0.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:16:33,610:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 19:16:33,611:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:16:33,614:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:16:33,616:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:16:45,514:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 0.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:16:45,619:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py:138: FitFailedWarning: Metric 'make_scorer(roc_auc_score, needs_proba=True, error_score=0.0, average=weighted, multi_class=ovr)' failed and error score 0.0 has been returned instead. If this is a custom metric, this usually means that the error is in the metric code. Full exception below:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 76, in _cached_call
    return cache[method]
KeyError: 'predict_proba'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\metrics.py", line 130, in _score
    return super()._score(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 316, in _score
    y_pred = method_caller(clf, "predict_proba", X)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_scorer.py", line 78, in _cached_call
    result = getattr(estimator, method)(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 121, in __getattr__
    return getattr(self._final_estimator, name)
AttributeError: 'RidgeClassifier' object has no attribute 'predict_proba'

  warnings.warn(

2023-06-19 19:16:45,621:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:16:45,622:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:16:45,628:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:16:45,768:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
1 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 260, in fit
    fitted_estimator = self._memory_fit(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 66, in _fit_one
    transformer.fit(*args, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_ridge.py", line 1424, in fit
    super().fit(X, Y, sample_weight=sample_weight)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_ridge.py", line 866, in fit
    X, y, X_offset, y_offset, X_scale = _preprocess_data(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\linear_model\_base.py", line 252, in _preprocess_data
    X_offset = np.average(X, axis=0, weights=sample_weight)
  File "<__array_function__ internals>", line 180, in average
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\numpy\lib\function_base.py", line 550, in average
    avg = np.multiply(a, wgt,
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (5648, 16384) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 19:16:45,780:INFO:Calculating mean and std
2023-06-19 19:16:45,824:INFO:Creating metrics dataframe
2023-06-19 19:16:46,025:INFO:Uploading results into container
2023-06-19 19:16:46,028:INFO:Uploading model into container now
2023-06-19 19:16:46,036:INFO:_master_model_container: 6
2023-06-19 19:16:46,036:INFO:_display_container: 2
2023-06-19 19:16:46,042:INFO:RidgeClassifier(alpha=1.0, class_weight=None, copy_X=True, fit_intercept=True,
                max_iter=None, positive=False, random_state=123, solver='auto',
                tol=0.0001)
2023-06-19 19:16:46,042:INFO:create_model() successfully completed......................................
2023-06-19 19:16:46,808:INFO:SubProcess create_model() end ==================================
2023-06-19 19:16:46,808:INFO:Creating metrics dataframe
2023-06-19 19:16:46,828:INFO:Initializing Random Forest Classifier
2023-06-19 19:16:46,828:INFO:Total runtime is 34.319002612431845 minutes
2023-06-19 19:16:46,831:INFO:SubProcess create_model() called ==================================
2023-06-19 19:16:46,832:INFO:Initializing create_model()
2023-06-19 19:16:46,832:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000114195CF5E0>, estimator=rf, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001143F306AD0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 19:16:46,832:INFO:Checking exceptions
2023-06-19 19:16:46,832:INFO:Importing libraries
2023-06-19 19:16:46,833:INFO:Copying training dataset
2023-06-19 19:16:47,744:INFO:Defining folds
2023-06-19 19:16:47,745:INFO:Declaring metric variables
2023-06-19 19:16:47,748:INFO:Importing untrained model
2023-06-19 19:16:47,752:INFO:Random Forest Classifier Imported successfully
2023-06-19 19:16:47,759:INFO:Starting cross validation
2023-06-19 19:16:48,285:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 19:16:51,745:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:16:51,873:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:16:51,912:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:16:51,923:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:16:51,931:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:16:51,958:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:16:51,979:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:16:51,989:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:16:54,951:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:00,865:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:05,306:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:05,585:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:05,596:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:05,812:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:05,878:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:06,867:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:06,867:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:17:07,867:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:08,160:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:08,355:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:08,723:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:17:09,305:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:09,567:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:17:10,598:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.99s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:17:11,242:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:17:45,364:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.26s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:57,338:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.45s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:57,434:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:58,201:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:59,392:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:59,475:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.69s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:17:59,690:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:18:00,278:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.48s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:18:02,241:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:18:17,406:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 3.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:18:21,851:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:18:23,773:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 6.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:18:23,795:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 6.21s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:18:23,964:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 9.44s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:18:24,934:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:18:24,879:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 7.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:18:25,035:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:18:43,853:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 3.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:18:47,507:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 6.14s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:18:47,511:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 6.40s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:18:47,530:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 6.01s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:18:50,100:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:19:07,483:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 4.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:19:27,570:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 12.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:19:30,526:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 14.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:19:48,676:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.45s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:19:48,994:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.80s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:19:54,607:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 5.99s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:19:55,782:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.28s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:19:56,690:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:19:57,126:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.11s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:19:58,086:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:19:58,251:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.08s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:19:58,392:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:19:59,262:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.03s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:19:59,702:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:20:00,704:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.82s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:20:00,837:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.82s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:20:02,415:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:20:02,777:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.15s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:20:03,048:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:20:03,316:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:20:04,358:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:20:04,415:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.49s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:20:04,780:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:20:04,858:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.03s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:20:05,071:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:20:06,991:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:07,004:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:07,010:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:07,240:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:07,248:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:07,258:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:08,231:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:08,236:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:08,245:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:08,329:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:08,337:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:08,346:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:08,454:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:20:08,933:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:20:11,191:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:20:11,574:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:11,583:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:11,589:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:12,244:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.85s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:20:12,420:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.82s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:20:13,048:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.47s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:20:13,717:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.46s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:20:15,124:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:20:15,350:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:15,357:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:15,363:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:32,476:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:32,482:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:32,487:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:20:47,922:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:20:50,620:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:20:51,457:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:21:09,568:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:21:15,767:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.32s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:21:17,312:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:21:17,314:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:21:17,317:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:21:17,520:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.26s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:21:18,841:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:21:18,845:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:21:18,850:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:21:18,991:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py:378: FitFailedWarning: 
1 fits failed out of a total of 10.
The score on these train-test partitions for these parameters will be set to 0.
If these failures are not expected, you can try to debug them by setting error_score='raise'.

Below are more details about the failures:
--------------------------------------------------------------------------------
1 fits failed with the following error:
Traceback (most recent call last):
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\model_selection\_validation.py", line 686, in _fit_and_score
    estimator.fit(X_train, y_train, **fit_params)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 255, in fit
    X, y, _ = self._fit(X, y, **fit_params_steps)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 238, in _fit
    X, y = self._memory_transform(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\joblib\memory.py", line 594, in __call__
    return self._cached_call(args, kwargs)[0]
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 398, in _cached_call
    out, metadata = self.call(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\memory.py", line 309, in call
    output = self.func(*args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py", line 77, in _transform_one
    output = transformer.transform(*args)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\utils\_set_output.py", line 140, in wrapped
    data_to_wrap = f(self, X, *args, **kwargs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\preprocess\transformers.py", line 247, in transform
    args.append(X[self._include])
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\frame.py", line 3819, in __getitem__
    data = self._take_with_is_copy(indexer, axis=1)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3902, in _take_with_is_copy
    result = self._take(indices=indices, axis=axis)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\generic.py", line 3886, in _take
    new_data = self._mgr.take(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 978, in take
    return self.reindex_indexer(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 743, in reindex_indexer
    new_blocks, new_refs = self._slice_take_blocks_ax0(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\managers.py", line 912, in _slice_take_blocks_ax0
    nb = blk.take_nd(taker, axis=0, new_mgr_locs=mgr_locs)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\internals\blocks.py", line 880, in take_nd
    new_values = algos.take_nd(
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 117, in take_nd
    return _take_nd_ndarray(arr, indexer, axis, fill_value, allow_fill)
  File "c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pandas\core\array_algos\take.py", line 158, in _take_nd_ndarray
    out = np.empty(out_shape, dtype=dtype)
numpy.core._exceptions._ArrayMemoryError: Unable to allocate 706. MiB for an array with shape (16384, 5644) and data type float64

  warnings.warn(some_fits_failed_message, FitFailedWarning)

2023-06-19 19:21:19,014:INFO:Calculating mean and std
2023-06-19 19:21:19,088:INFO:Creating metrics dataframe
2023-06-19 19:21:19,350:INFO:Uploading results into container
2023-06-19 19:21:19,355:INFO:Uploading model into container now
2023-06-19 19:21:19,367:INFO:_master_model_container: 7
2023-06-19 19:21:19,367:INFO:_display_container: 2
2023-06-19 19:21:19,379:INFO:RandomForestClassifier(bootstrap=True, ccp_alpha=0.0, class_weight=None,
                       criterion='gini', max_depth=None, max_features='sqrt',
                       max_leaf_nodes=None, max_samples=None,
                       min_impurity_decrease=0.0, min_samples_leaf=1,
                       min_samples_split=2, min_weight_fraction_leaf=0.0,
                       n_estimators=100, n_jobs=-1, oob_score=False,
                       random_state=123, verbose=0, warm_start=False)
2023-06-19 19:21:19,379:INFO:create_model() successfully completed......................................
2023-06-19 19:21:20,213:INFO:SubProcess create_model() end ==================================
2023-06-19 19:21:20,213:INFO:Creating metrics dataframe
2023-06-19 19:21:20,407:INFO:Initializing Quadratic Discriminant Analysis
2023-06-19 19:21:20,407:INFO:Total runtime is 38.87865801652273 minutes
2023-06-19 19:21:20,416:INFO:SubProcess create_model() called ==================================
2023-06-19 19:21:20,417:INFO:Initializing create_model()
2023-06-19 19:21:20,417:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000114195CF5E0>, estimator=qda, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001143F306AD0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 19:21:20,417:INFO:Checking exceptions
2023-06-19 19:21:20,417:INFO:Importing libraries
2023-06-19 19:21:20,442:INFO:Copying training dataset
2023-06-19 19:21:24,861:INFO:Defining folds
2023-06-19 19:21:24,861:INFO:Declaring metric variables
2023-06-19 19:21:24,866:INFO:Importing untrained model
2023-06-19 19:21:24,871:INFO:Quadratic Discriminant Analysis Imported successfully
2023-06-19 19:21:24,877:INFO:Starting cross validation
2023-06-19 19:21:25,534:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 19:21:28,694:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:21:28,723:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:21:28,751:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.62s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:21:28,765:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:21:28,791:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:21:28,821:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:21:28,853:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:21:28,883:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:21:36,782:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:21:42,319:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:21:42,613:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.59s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:21:42,738:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:21:53,419:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:22:01,120:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.58s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:22:01,227:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:22:01,484:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:22:34,715:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:22:36,462:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.12s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:22:36,733:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:22:36,980:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:22:38,768:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.45s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:22:39,432:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.77s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:22:40,159:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:22:40,672:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:22:49,375:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.99s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:22:55,271:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.31s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:22:55,366:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.44s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:22:55,605:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.44s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:22:58,396:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:23:00,755:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 3.29s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:23:01,192:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.07s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:23:02,337:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.41s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:23:03,651:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:23:16,137:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 7.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:23:17,494:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 8.43s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:23:18,464:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.29s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:23:19,452:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:23:19,463:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:23:20,268:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 12.06s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:23:20,621:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:23:28,414:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 19:23:56,623:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 19:23:58,281:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 19:24:00,619:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 19:24:00,767:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 19:24:01,439:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 19:24:01,723:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 19:24:01,975:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 19:25:36,862:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 7.43s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:25:46,031:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.09s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:25:48,304:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:25:53,704:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 5.37s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:26:05,520:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:26:06,992:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:26:08,117:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 3.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:26:09,155:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 4.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:26:09,302:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 4.30s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:26:09,656:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 5.34s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:26:09,850:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 5.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:26:10,789:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 5.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:26:11,045:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 5.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:26:11,183:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:319: UserWarning: Persisting input arguments took 4.17s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:26:15,124:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:15,133:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:15,138:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 19:26:15,142:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:15,529:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.07s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:26:16,422:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:26:16,768:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.09s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:26:16,850:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:26:17,505:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.27s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:26:17,644:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:26:18,004:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:26:18,149:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 1.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:26:18,765:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:26:18,847:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:26:18,887:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:26:19,543:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.66s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:26:20,046:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:26:20,207:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.63s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:26:21,386:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 3.68s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:26:22,653:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.16s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:26:23,004:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 4.09s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:26:23,090:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 4.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:26:24,633:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 5.03s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:26:25,143:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 4.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:26:26,109:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 5.78s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:26:26,682:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 7.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:26:27,473:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.98s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:26:33,974:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:26:36,828:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:36,848:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:36,867:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 19:26:36,870:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:39,302:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:39,328:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:39,338:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 19:26:39,342:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:40,305:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:40,316:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:40,345:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 19:26:40,350:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:41,563:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:41,574:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:41,579:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 19:26:41,581:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:41,739:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:41,747:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:41,753:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 19:26:41,758:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:42,990:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:42,996:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:42,999:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 19:26:43,003:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:43,342:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:43,348:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:43,350:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 19:26:43,352:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:26:43,954:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:27:11,123:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:27:14,387:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 19:27:26,192:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\discriminant_analysis.py:926: UserWarning: Variables are collinear
  warnings.warn("Variables are collinear")

2023-06-19 19:27:59,624:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.17s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:28:06,544:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.20s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:28:09,386:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 1.04s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:28:12,952:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:28:12,956:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:28:12,958:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 19:28:12,962:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:28:15,777:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:28:20,908:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:28:20,911:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:28:20,913:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 19:28:20,914:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:28:21,082:INFO:Calculating mean and std
2023-06-19 19:28:21,137:INFO:Creating metrics dataframe
2023-06-19 19:28:21,430:INFO:Uploading results into container
2023-06-19 19:28:21,438:INFO:Uploading model into container now
2023-06-19 19:28:21,451:INFO:_master_model_container: 8
2023-06-19 19:28:21,451:INFO:_display_container: 2
2023-06-19 19:28:21,459:INFO:QuadraticDiscriminantAnalysis(priors=None, reg_param=0.0,
                              store_covariance=False, tol=0.0001)
2023-06-19 19:28:21,459:INFO:create_model() successfully completed......................................
2023-06-19 19:28:22,272:INFO:SubProcess create_model() end ==================================
2023-06-19 19:28:22,272:INFO:Creating metrics dataframe
2023-06-19 19:28:22,307:INFO:Initializing Ada Boost Classifier
2023-06-19 19:28:22,307:INFO:Total runtime is 45.91031945943833 minutes
2023-06-19 19:28:22,311:INFO:SubProcess create_model() called ==================================
2023-06-19 19:28:22,311:INFO:Initializing create_model()
2023-06-19 19:28:22,312:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000114195CF5E0>, estimator=ada, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001143F306AD0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 19:28:22,312:INFO:Checking exceptions
2023-06-19 19:28:22,312:INFO:Importing libraries
2023-06-19 19:28:22,313:INFO:Copying training dataset
2023-06-19 19:28:23,572:INFO:Defining folds
2023-06-19 19:28:23,573:INFO:Declaring metric variables
2023-06-19 19:28:23,579:INFO:Importing untrained model
2023-06-19 19:28:23,584:INFO:Ada Boost Classifier Imported successfully
2023-06-19 19:28:23,594:INFO:Starting cross validation
2023-06-19 19:28:24,247:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 19:28:27,836:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:28:27,837:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:28:27,870:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:28:27,885:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:28:27,924:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:28:27,952:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.92s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:28:27,976:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:28:27,989:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:28:41,990:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:28:42,266:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.61s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:28:42,406:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:28:42,406:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:28:49,287:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.99s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:29:10,333:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 9.49s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:29:10,346:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 9.36s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:29:10,618:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 9.11s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:29:11,671:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:29:46,550:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:29:46,556:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.02s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:29:46,807:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.27s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:29:46,811:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.27s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:29:48,868:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:29:51,412:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:29:51,416:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:29:51,471:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.57s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:30:04,178:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.20s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:30:04,588:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 2.33s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:30:04,907:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:30:13,597:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:40:47,067:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:40:51,352:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.67s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:40:52,875:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:40:55,047:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.11s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:30:04,942:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.53s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:30:27,192:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.96s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:40:55,597:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:30:27,767:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 11.33s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:40:58,823:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:41:00,300:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:00,308:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:00,315:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:00,453:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:30:12,783:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.82s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:30:28,231:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:41:00,752:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:30:12,695:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.73s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:30:28,230:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:41:01,168:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.99s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:30:06,420:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.48s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:30:26,694:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 2.01s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:41:01,873:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:41:02,625:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.74s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:41:02,829:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:30:26,877:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:41:03,102:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:260: UserWarning: Persisting input arguments took 0.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_estimator = self._memory_fit(

2023-06-19 19:41:03,207:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:41:03,900:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.71s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:41:03,930:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.89s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:41:05,597:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:41:05,752:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:41:05,868:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.65s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:41:06,052:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.89s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:41:06,115:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.85s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:41:06,796:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.83s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:41:08,740:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.79s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:41:11,375:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:11,385:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:11,391:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:11,486:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:11,494:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:11,502:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:11,936:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:11,944:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:11,953:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:12,604:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:12,614:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:12,617:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))

2023-06-19 19:41:12,618:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:30:12,775:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:30:27,562:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.49s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:41:13,069:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 6.90s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:41:13,877:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.80s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:41:14,099:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:41:14,770:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.56s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:41:15,371:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.52s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:41:15,471:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:108: UserWarning: Persisting input arguments took 0.55s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = pipeline._memory_transform(transformer, X, y)

2023-06-19 19:41:16,842:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:16,978:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:41:17,004:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.08s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:41:17,194:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:17,198:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:18,072:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 2.14s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:41:27,003:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:27,099:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:27,106:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:28,318:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:28,881:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:28,888:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:41:51,822:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.60s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:41:53,474:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:48:07,051:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 1.19s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:48:09,654:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:48:09,657:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:48:09,660:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:48:17,574:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:310: UserWarning: Persisting input arguments took 0.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, _ = self._memory_full_transform(self, X, None, with_final=False)

2023-06-19 19:48:19,698:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:48:19,701:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:48:19,704:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\sklearn\metrics\_classification.py:1396: UserWarning: Note that pos_label (set to 'Very_Mild_Demented') is ignored when average != 'binary' (got 'weighted'). You may use labels=[pos_label] to specify a single positive class.
  warnings.warn(

2023-06-19 19:48:19,853:INFO:Calculating mean and std
2023-06-19 19:48:19,912:INFO:Creating metrics dataframe
2023-06-19 19:48:20,189:INFO:Uploading results into container
2023-06-19 19:48:20,193:INFO:Uploading model into container now
2023-06-19 19:48:20,201:INFO:_master_model_container: 9
2023-06-19 19:48:20,201:INFO:_display_container: 2
2023-06-19 19:48:20,206:INFO:AdaBoostClassifier(algorithm='SAMME.R', base_estimator='deprecated',
                   estimator=None, learning_rate=1.0, n_estimators=50,
                   random_state=123)
2023-06-19 19:48:20,206:INFO:create_model() successfully completed......................................
2023-06-19 19:48:20,975:INFO:SubProcess create_model() end ==================================
2023-06-19 19:48:20,976:INFO:Creating metrics dataframe
2023-06-19 19:48:21,011:INFO:Initializing Gradient Boosting Classifier
2023-06-19 19:48:21,011:INFO:Total runtime is 65.88872955242793 minutes
2023-06-19 19:48:21,014:INFO:SubProcess create_model() called ==================================
2023-06-19 19:48:21,015:INFO:Initializing create_model()
2023-06-19 19:48:21,015:INFO:create_model(self=<pycaret.classification.oop.ClassificationExperiment object at 0x00000114195CF5E0>, estimator=gbc, fold=StratifiedKFold(n_splits=10, random_state=None, shuffle=False), round=4, cross_validation=True, predict=True, fit_kwargs={}, groups=None, refit=False, probability_threshold=None, experiment_custom_tags=None, verbose=False, system=False, add_to_model_list=True, metrics=None, display=<pycaret.internal.display.display.CommonDisplay object at 0x000001143F306AD0>, model_only=True, return_train_score=False, kwargs={})
2023-06-19 19:48:21,015:INFO:Checking exceptions
2023-06-19 19:48:21,015:INFO:Importing libraries
2023-06-19 19:48:21,016:INFO:Copying training dataset
2023-06-19 19:48:22,141:INFO:Defining folds
2023-06-19 19:48:22,141:INFO:Declaring metric variables
2023-06-19 19:48:22,146:INFO:Importing untrained model
2023-06-19 19:48:22,152:INFO:Gradient Boosting Classifier Imported successfully
2023-06-19 19:48:22,162:INFO:Starting cross validation
2023-06-19 19:48:22,754:INFO:Cross validating with StratifiedKFold(n_splits=10, random_state=None, shuffle=False), n_jobs=-1
2023-06-19 19:48:37,184:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.94s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:48:37,189:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.84s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:48:37,190:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:48:37,207:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.93s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:48:37,215:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.95s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:48:37,228:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.88s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:48:43,206:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.70s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:48:43,303:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:48:43,477:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.86s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:48:43,672:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.91s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:48:43,742:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.97s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:48:43,780:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.00s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:49:14,719:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 1.75s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:49:21,386:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 7.00s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:49:21,396:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.50s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:49:21,705:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.80s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:49:21,732:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.72s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:49:22,411:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.51s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:49:22,785:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 0.54s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:49:23,179:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:238: UserWarning: Persisting input arguments took 0.64s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  X, y = self._memory_transform(

2023-06-19 19:49:48,031:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 4.29s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 19:49:49,278:WARNING:c:\Users\joao.correia\Documents\Faculdade\Monografia_Joao_Victor_A_Correia\.conda\lib\site-packages\pycaret\internal\pipeline.py:231: UserWarning: Persisting input arguments took 1.24s to run.
If this happens often in your code, it can cause performance problems 
(results will be correct in all cases). 
The reason for this is probably some large input arguments for a wrapped
 function (e.g. large strings).
THIS IS A JOBLIB ISSUE. If you can, kindly provide the joblib's team with an
 example so that they can fix the problem.
  fitted_transformer = self._memory_fit(

2023-06-19 22:56:19,009:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 22:56:19,009:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 22:56:19,009:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 22:56:19,009:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-19 22:56:25,082:WARNING:
'prophet' is a soft dependency and not included in the pycaret installation. Please run: `pip install prophet` to install.
2023-06-30 20:18:59,064:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-30 20:18:59,078:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-30 20:18:59,079:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-30 20:18:59,079:WARNING:
'cuml' is a soft dependency and not included in the pycaret installation. Please run: `pip install cuml` to install.
2023-06-30 20:19:04,086:WARNING:
'prophet' is a soft dependency and not included in the pycaret installation. Please run: `pip install prophet` to install.
